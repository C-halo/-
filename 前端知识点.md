## JS/ES6

### Promise

使异步操作同步执行，解决异步流程化的一个手段,

Promise中的代码与下方是同步执行，但then函数中是异步执行。

```js
console.log('1')
new Promise((resolve, reject) => {
    console.log('2')
        resolve(1)
    }).then(value => {
    console.log('4')
    console.log('value',value)
},reason => {
    console.log('reason',reason)
})
console.log('3')
//1 2 3 4 value 1
```



**Promise.catch()**

是 .then(null, rejection) 或是 .then(undefined, rejection)的别名，用于指定发生错误时的回调函数。

```js
p.then((val) => console.log('fulfilled:', val))//resolve则执行then
  .catch((err) => console.log('rejected', err));//reject则执行catch

// 等同于
p.then((val) => console.log('fulfilled:', val))
  .then(null, (err) => console.log("rejected:", err));

let p = new Promise((resolve, reject) => {
    let a = 5;
    if (a === 5) resolve(5);
    else {
        reject('erro')
    };
})
p.then(val => {
    console.log(val);
    throw new Error('ssss')
}).catch(err => console.log('err'));
```



**promise.all()**

```
**返回所有的promise，要都成功才能resolve()**
```

**promise.race() **

```
谁先完成就返回那个的结果（测试资源的响应速度）
```

**promise.any()**

```
只要其中的一个 `promise` 成功，就返回那个已经成功的 `promise` 。如果都失败了，返回失败的集合，返回一个失败的 promise 
```



### 手写Promise

首先Promise是一个函数或者说是对象，含有then方法，其也是一个函数

在New Promise时，传入一个函数，这个函数的参数是两个方法，(resolve,reject)=>{}，目的是让promise的状态改变。

promise的三种状态(pending,resolved,rejected)，状态不可逆

resolve函数执行后，状态变为resolved，并且保存传入的参数为value

反之reject函数执行，状态变为rejected，将原因存入reason

在prototype上定义then方法，参数是两个函数(onFulfilled,OnRejected)，如果是成功状态，将value传给onFulfilled并执行；是失败状态，将reason传给OnRejected并执行

```js
let myPromise = function (constructor) {
    let self = this;
    self.status = 'pending'
    self.value = undefined;
    self.reason = undefined;
    let resolve = (value) => {
        if (self.status === 'pending') {
            self.value = value;
            self.status = 'resolved'
        }
    }
    let reject = (reason) => {
        if (self.status === 'pending') {
            self.reason = reason;
            self.status = 'rejected'
        }
    }
    try {
        constructor(resolve, reject);//执行传入的方法，第一个参数绑定为resolve，第二个绑定为reject
    } catch (e) {
        reject(e);
    }
}

myPromise.prototype.then = function (onFullfilled, onRejected) {
    let self = this;
    if (self.status === 'resolved') {
        onFullfilled(self.value);
    }
    if (self.status === 'rejected') {
        onRejected(self.reason);
    }
}

let p = new myPromise((resolve, reject) => {
    resolve(2);
}).then(x => console.log(x + 1))
```



### async和await

async做了一件什么事情？

async将你的函数返回值转换为promise对象，不需要显式地返回promise对象，async关键字自动将函数的返回值变为promise对象。

- async函数的返回值为promise对象
- async返回的promise对象的结果值由async函数执行的返回值决定

```js
async function fn(){
   //1.无返回值，则fn也无返回值
   //2.如果返回的是一个非Promise的对象，则fn（）返回的结果就是成功状态的Promise对象，值为返回值
   //3.如果返回的是一个Promise对象，则fn（）返回的结果与内部Promise对象的结果一致
   //4.如果返回的是抛出错误，则fn（）返回的就是失败状态的Promise对象
   return new Promise((resolve,reject)=>{
       resolve('成功的数据');
   });
}
const result = fn();
result.then(value=>{
   console.log(value)  //成功的数据
},reason=>{
   console.log(reason)
})
```

await

当程序执行到await方法时，会阻塞await方法后面的代码，进入await方法内部并执行到return前，然后跳出该async方法，执行与该async方法并列的同步任务。

```js
async function test1() {
	console.log('start test1');
	console.log(await test2());
	console.log('end test1');
}
async function test2() {
	console.log('test2');
	return await 'return test2 value'//是因为这里返回的是promise对象，又推到微任务中了
}
test1();

console.log('start async');

setTimeout(() => {
	console.log('setTimeout');
}, 0);

new Promise((resolve, reject) => {
	console.log('promise1');
	resolve();
}).then(() => {
	console.log('promise2');
});

console.log('end async');
// start test1
// test2
// start async
// promise1
// end async
// promise2
// return test2 value
// end test1
// setTimeout
```

```js
async function test1() {
	console.log('start test1');
	console.log(await test2());
	console.log('end test1');
}
async function test2() {
	console.log('test2');
	return  'return test2 value'//假如此处返回的不是promise对象
}
test1();

console.log('start async');

setTimeout(() => {
	console.log('setTimeout');
}, 0);

new Promise((resolve, reject) => {
	console.log('promise1');
	resolve();
}).then(() => {
	console.log('promise2');
});

console.log('end async');
// start test1
// test2
// start async
// promise1
// end async
// return test2 value
// end test1
// promise2
// setTimeout
```

### 闭包

就是嵌套的内部函数，其使用了外部函数的变量，相当于创建了一个函数对象，带一堆变量
优点：延长了局部变量的生命周期，外部函数可以读取到内部的数据
缺点：容易污染变量，浪费内存

### ES6新特性

```
let和const     数组和对象的解构 
模板字符串
let lovest = 'RHF';
let out = `${lovest}是最帅的`;
箭头函数  扩展运算符[...arr]
```

### var let const的区别

```
var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问，变量提升。
let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。
const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。
```

### var做了什么

```
var name = 'iceman'
编译器在当前作用域中声明一个变量name  //变量提升
运行时引擎在作用域中查找该变量，找到了name变量并为其赋值

其实编译器是这样工作的，在代码执行之前从上到下的进行编译，当遇到某个用var声明的变量的时候，先检查在当前作用域下是否存在了该变量。如果存在，则忽略这个声明；如果不存在，则在当前作用域中声明该变量
```



### 作用域

全局作用域：可以看作是一个IIFE立即执行函数

函数作用域：其中的变量会被提升

块级作用域：while{} if{} {}

### Js中的this指向

this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象

指向调用这个函数的**对象**

- test(): window
- p.test(): p
- new test(): 新创建的对象
- p.call(obj): obj

```js
var o = {
    a:10,
    b:{
        // a:12,
        fn:function(){
            console.log(this.a); //undefined
        }
    }
}
o.b.fn();//this指向b对象
```

```js
var o = {
    a:10,
    b:{
        a:12,
        fn:function(){
            console.log(this.a); //undefined
            console.log(this); //window
        }
    }
}
var j = o.b.fn;
j();//this指向window
```



为什么this会指向a？首先new关键字会创建一个空的对象，然后会自动调用一个函数apply方法，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代。

```js
function fn(){
    this.num = 1;
}
var a = new fn();
console.log(a.num); //1
```



**当this碰到return时**

如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。

```js
function fn()  
{  
    this.user = '追梦子';  
    return {};  
}
var a = new fn;  
console.log(a.user); //undefined
```

```js
function fn()  
{  
    this.user = '追梦子';  
    return undefined;
}
var a = new fn;  
console.log(a.user); //追梦子
```

虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。

```js
function fn()  
{  
    this.user = '追梦子';  
    return null;
}
var a = new fn;  
console.log(a.user); //追梦子
```



### 箭头函数

- 内部是不绑定this的，**它本来就是为了利用作用域链查找机制！！！**
- **正因为它**内部没有this，所以在它内部使用this时**永远都会指向“父级”作用域！！！**

#### 1.this在箭头函数中被绑定

this是静态的，this始终指向函数声明时函数所在作用域下的this的值

有对象和全局作用域,函数作用域

```js
function A(){ //所在作用域是window
    console.log(this.name)
}

let B = () => {//所在作用域是window
    console.log(this.name);
}

window.name = '尚硅谷';
const school = {
    name: 'ATGUIGU'
}

//直接调用
A()   //尚硅谷
B()  //尚硅谷

//call
A.call(school); //ATGUIGU
B.call(school);  //尚硅谷  //箭头函数，call不改变this的值
```

字面量对象无法形成自己的一层作用域

```js
this.name = 'eono'
const obj = {
    name: 'halo',
    fun1: () => {
        console.log(this.name); //箭头函数
    },
    fun2: function () {
        console.log(this.name);//普通函数
    }
}
obj.fun1();//eono
obj.fun2();//halo
```

```js
const obj = {
  fun1: function () {
    console.log(this);
    return () => {
      console.log(this);
    }
  },
  fun2: function () {
    return function () {
      console.log(this);
      return () => {
        console.log(this);
      }
    }
  },
  fun3: () => {
    console.log(this);
  }
}
 
let f1 = obj.fun1(); // obj
f1() // obj
 
let f2 = obj.fun2();//普通函数的this发生的变化，调用对象相当于变成了全局
let f2_2 = f2(); // window
f2_2() // window
 
obj.fun3(); // window
```

- 问题: 箭头函数中的this是如何查找的?
- 答案: 向外层作用域中, 一层层查找this, 直到有this的定义.

```js
const obj = {
      aaa() {
        setTimeout(function () {
          console.log(this); // window
        })
 
        setTimeout(() => {
          console.log(this); // 往外面找，找到了aaa()中的this，谁调用aaa(),this就指向谁
        })
      }
    }
```

```js
 const obj = {
      aaa() {
        setTimeout(function () {
          setTimeout(function () {
            console.log(this); // window
          })
 
          setTimeout(() => {
            console.log(this); // window  setTimeout指向的this就是window
          })
        })
 
        setTimeout(() => {
          setTimeout(function () {
            console.log(this); // window
          })
 
          setTimeout(() => {
            console.log(this); // obj   此层的setTimeout等于上一层setTimeout箭头函数的this,而上一层的箭头函数位于aaa()作用域下，等于aaa()中的this
          })
        })
      }
    }
```

#### 2.不能作为构造实例化对象

```js
let A=(name,age) => {
    this.name=name;
    this.age=age;
}
let me = new A('xiao',123);
console.log(me) //A is not a constructor
```

#### 3.不能使用arguments变量

```js
let fn = () => {
    console.log(arguments)
}
fn(1,2,3)  //error
```

简写

​	省略小括号，当形参有且只有一个的时候

```js
let add = n => {
    return n + 1;
}
```

省略花括号，当代码体只有一条语句的时候，此时return也必须省略

```js
let add = n => n+1;
```

### 箭头函数的实践

箭头函数适合与this无关的回调，定时器，数组方法的回调

不适合与this有关的回调，事件回调，对象的方法

```js
const arr = [1, 6, 9, 10, 100, 200];
const result = arr.filter(item => item % 2 == 0)//返回偶数
console.log(result);
```



### call(),apply(),bind()

**call()**

```js
var a = {
    user:"追梦子",
    fn:function(e,ee){
        console.log(this.user); //追梦子
        console.log(e+ee); //3
    }
}
var b = a.fn;
b.call(a,1,2);
```

**apply()**

同样apply也可以有多个参数，但是不同的是，第二个参数必须是一个数组，如下：

```js
var a = {
    user:"追梦子",
    fn:function(e,ee){
        console.log(this.user); //追梦子
        console.log(e+ee); //11
    }
}
var b = a.fn;
b.apply(a,[10,1]);
```

**bind()**

bind方法返回的是一个修改过后的函数，参数不是数组

```js
var a = {
    user:"追梦子",
    fn:function(){
        console.log(this.user);
    }
}
var b = a.fn;
var c = b.bind(a);
console.log(c); //function() { [native code] }
c();//这样才能输出 追梦子
```

参数

```js
var a = {
    user:"追梦子",
    fn:function(e,d,f){
        console.log(this.user); //追梦子
        console.log(e,d,f); //10 1 2
    }
}
var b = a.fn;
var c = b.bind(a,10);
c(1,2);
```

### New关键字执行步骤

```js
let fn = New Fn();
//1.创建了一个空对象
let obj = new Object();
//2.让obj的_proto_指向构造函数的prototype;
obj._proto_ = Fn.prototype;
//3.让构造函数中的this指向新建的对象,并执行构造函数
let res = Fn.call(obj);
//4.根据res的类型给fn返回不同的值,既让fn指向哪里？
return res instanceof Object?res:obj;
//基本数据类型number,string,null等会返回新建的对象obj；若构造函数返回引用类型的，则fn指向返回的引用类型
```



### 原型链

<img src="C:\Users\halo\Desktop\前端知识点.assets\image-20210714212945164.png" alt="image-20210714212945164" style="zoom:67%;" />

```
这里少了Foo.prototype 和Function.prototype指向Object.prototype的线    _proto_
```

### typeof 和 instanceof区别

typeof x //返回字符串,说明其类型  ,无法区分array和object

```js
typeof 1 //number
typeof '2'//string
typeof true//boolean
typeof undefined//undefined
typeof null//object
typeof deepclone//function
typeof [1, 2, 3]//object
typeof { a: 2 }//object
```

a insatanceof A //判断a是不是A的实例对象，实际是看A.prototype在不在a的原型链上,返回true of false

可以区分array和object,用来判断是不是引用类型

```js
[1, 2, 3] instanceof Array//true
{ a: 2 } instanceof Array//false
Fn instanceof Array//false
1 instanceof Array//false
"hello" instanceof Array//false
true instanceof Array//false
null instanceof Object//false
```



### 获取对象上的键名

```js
let test = {
    a: 2,
    b: 1,
    c: 3
}
console.log(Object.keys(test));
for(let i in test){
    console.log(i);
}
console.log(Object.getOwnPropertyNames(test));	
```



### 深浅拷贝

深拷贝：将值赋给另一变量，既直接在堆中开辟一块空间。

基本数据的赋值都是

```js
var a = 1;
var b = a;//复制
console.log(b)//1
a = 2;//改变a的值
console.log(b)//1
console.log(a) //2
```

浅拷贝：将堆中的地址赋值给另一引用类型的变量

引用类型赋值

```js
var arr1 = ['red','green'];
var arr2 = arr1;//复制
console.log(arr2)//['red','green'];
arr1.push('black') ;//改变color1的值
console.log(arr2)//['red','green','black']
console.log(arr1) //["red", "green", "black"]
```

slice和concat仅仅对于一维数组是深拷贝，但是在二维数组上会出现问题

```js
var arr1 = ['red','green'];
var arr2 = arr1.slice(0);//复制
console.log(arr2)//['red','green'];
arr1.push('black') ;//改变color1的值
console.log(arr2)//["red", "green"]
console.log(arr1)//["red", "green", "black"
```

```js
var arr1=[1,2,3,['1','2','3']];
var arr2=arr1.slice(0);
 arr1[3][0]=0;
 console.log(arr1);//[1,2,3,['0','2','3']]
 console.log(arr2);//[1,2,3,['0','2','3']]
```

修改单个值会，但是如何下面让某一行重新指向一个新数组，不会影响

```js
var arr1 = [['x', 'y', 'z'], ['1', '2', '3']];
var arr2 = arr1.slice();
for (let i = 0; i < 2; i++) {
    arr2[i] = [1, 2];
}
console.log(arr1);//[ [ 'x', 'y', 'z' ], [ '1', '2', '3' ] ]
console.log(arr2);//[ [ 1, 2 ], [ 1, 2 ] ]
```



### 实现深拷贝

1.Object.assign() 实现对对象的一级深拷贝，对象中还有对象会出现和slice一样的情况。

2.JSON.parse(JSON.stringify())  只能拷贝数组

```js
var arr1 = ['red','green'];
var arr2 = JSON.parse(JSON.stringify(arr1));//复制
console.log(arr2)//['red','green'];
arr1.push('black') ;//改变color1的值
console.log(arr2)//["red", "green"]
console.log(arr1)//["red", "green", "black"]
```

3.递归  对象数组都可

lodash函数库实现深拷贝

```
lodash很热门的函数库，提供了 lodash.cloneDeep()实现深拷贝
```



### 事件监听

```
element.addEventListener(event, function, useCapture) 
用于向指定元素添加事件 
event：事件类型，如click、scroll、mousedown、resize等 
function：事件触发后调用的函数 
useCapture：描述事件传递方式，可选。默认为false即冒泡传递（由内向外）；true时为捕获传递（由外向内）
```



## Vue

### obj.defineProperty()

```js
<script type="text/javascript">
       let number = 18;
       let person = {
           name: '张三',
           sex:'男'
       }
       //此时age是不可以枚举的
       //往person对象里添加属性
       //关联
       Object.defineProperty(person,'age', {
           // value: 18,
           // enumerable: true, //此时代表这个属性是可以枚举的
           // writable: true, //代表可以重写该属性(控制属性是否被修改)
           // configurable:true, //控制属性是否可以被删除 默认为false

           //当读取person的age属性时get属性就会被调用，且返回值就是age的值
           //invoke property proxy映射数据代理
           get: function () {
               //测试它的调用情况
               console.log('@@@ GET AGE');
               //此时age的值依赖number的值
               return number
           },
           //当修改person的age属性时set(setter)属性就会被调用，且会收到修改的具体值
           set(v) {
               //测试
               console.log('CHANGE AGE');
               number=v;
           }
       });
```



### 手写数据双向绑定轮子

修改Input->span标签变化

index.html

```html
<body>
    <!-- <p></p>
    <input type="text"> -->
    <div id="app">
        <div>
            <input type="text" v-model='name' placeholder="姓名">
            <input type="text" v-model='age' placeholder="年龄">
            <input type="text" v-model='email' placeholder="邮箱">
            <input type="text" v-model='tel' placeholder="电话号码">
        </div>
        <div>
            <p>姓名：<span>{{name}}</span></p>
            <p>年龄：<span>{{age}}</span></p>
            <p>邮箱:<span>{{email}}</span></p>
            <p>
                <p>
                    电话:<span>{{tel}}</span>
                </p>
            </p>
        </div>
    </div>
    <!-- <script type="module" src="./index.js"></script> -->
    <script src="/MVVM.js"></script>
    <script>
        const app = new MVVM('#app',{
            name:'halo',
            age:'24',
            email:'869252661@qq.com',
            tel:'123456'
        })
    </script>
</body>
```

MMVM.JS

```js
class MVVM {
    constructor(el, data) {//构造函数
        this.el = document.querySelector(el);//获取页面的id为el的div
        this._data = data;
        this.domPool = {};
        this.init();
    }

    init() {
        this.initData();
        this.initDom();
    }

    initData() {
        const _this = this;
        this.data = {}
        for (let key in this._data) {//遍历key,将input与data绑定
            Object.defineProperty(this.data, key, {
                get() {
                    console.log('获取数据', key, _this._data[key]);
                    return _this._data[key];
                },
                set(val) {
                    console.log("设置数据", key, val);
                    _this.domPool[key].innerText = val;
                    _this._data[key] = val;
                }
            });
        }
    }

    initDom() {
        this.bindDom(this.el);
        this.bindInput(this.el);
        console.log(this.domPool);
    }

    bindDom(el) {
        const childNodes = el.childNodes;
        childNodes.forEach(item => {
            if (item.nodeType === 3) {//文本节点
                const _value = item.nodeValue;

                if (_value.trim().length) {
                    let _isValid = /\{\{(.+?)\}\}/.test(_value);
                    if (_isValid) {
                        const _key = _value.match(/\{\{(.+?)\}\}/)[1].trim();//获取{{}}包裹着的key
                        this.domPool[_key] = item.parentNode;
                        item.parentNode.innerText = this.data[_key] || undefined;//向其父节点既<span>添加data
                    }
                }
            }
            item.childNodes && this.bindDom(item);
        })
    }
    bindInput(el) {//绑定input事件
        const inputs = el.querySelectorAll('input');
        inputs.forEach(input => {
            const _vmodel = input.getAttribute('v-model');
            if (_vmodel) {
                input.addEventListener('keyup', this.handleInput.bind(this, _vmodel, input), false);
            }
        })
    }
    handleInput(key, input) {
        const _value = input.value;
        this.data[key] = _value;
        console.log(this.data);
    }
}
```





**@click参数问题**

```html
<!--1.事件调用的方法没有参数 ()可以不添加-->
  <button @click="btn1Click()">按钮1</button>//两者效果相同
  <button @click="btn1Click">按钮1</button>
```

```html
<!--2.若带有参数-->
<button @click="cl">按钮1</button>//传入event事件
<button @click="cl()">按钮2</button>//undefined
methods: {
        cl(abc) {
          console.log(abc);
        }
      }
```

```html
<!--3.方法定义时, 我们需要event对象, 同时又需要其他参数-->
  <!-- 在调用方式, 如何手动的获取到浏览器参数的event对象: $event-->
  <button @click="btn3Click(abc, $event)">按钮3</button>//否则会将event传入第一个参数
```



### Watch函数

```js
watch:{
        //监视的配置对象
        //watch不仅能监视data的普通属性，也可以检测计算属性
        isHot:{
            immediate: true, //当这个属性为true时，页面刚渲染就运行handler函数
            //handler 什么时候调用呢
            //当isHot发生改变就会调用该函数
            //handler接收两个参数，一个是这个状态参数改变前的值，另一个是改变后的旧值
            handler(newValue, preValue){
                console.log('ishot 被修改了');
                console.log(`newValue: ${newValue}, preValue: ${preValue}`);
            }
        }
    }
```

### computed 和 watch 的区别和运用的场景

```
computed是计算属性，依赖于其他值来计算，具有缓存，有getter和setter，一般用于模板渲染；
watch 用于监听，值改变执行回调，适合完成一系列复杂的逻辑。
```



### 响应式原理

整体思路是数据劫持 + 观察者模式

使用 Object.defineProperty 将属性进行数据劫持（只会劫持已存在的属性），数组则是通过重写数组来实现。每个属性都拥有自己的 dep 实例，存着它所依赖的 watcher （依赖收集）get，当属性变化后会通知自己对应的 watcher 去更新（派发更新）set。

1、Object.defineProperty 数据劫持。
2、使用 getter 收集依赖 ，setter 通知 watcher派发更新。
3、watcher 发布订阅模式。

```js
const obj = {
        message: '哈哈哈哈',
        name: 'yyy'
    }
    // 1.监听值的改变 -> Object.defineProperty(属性所在的对象,要添加或者修改的对象属性,属性描述符)
    Object.keys(obj).forEach(key => {
        let value = obj[key]

        Object.defineProperty(obj, key, {
            set(newValue) {
                console.log('监听' + key + '改变');
                // 告诉谁?谁用告诉谁?谁在用?
                // 根据解析html代码,获取到哪些人有用属性
                // 张三/李四/王五 在用
                value = newValue
                // dep.notify()// 通知
            },
            get() {
                // 谁用一次就会调用一次get
                // 张三: get -> update
                // 李四: get -> update
                // 王五: get -> update
                console.log('获取' + key + '对应的值');
                return value
            }
        })
    })
    // 2.发布者订阅者模式
    // 发布者
    class Dep { // 存储所有对属性有依赖的东西
        constructor() {
            this.subscribe = [] // subscribe 订阅 这个数组记录谁要订阅属性
        }
        addSub(watcher) {
            this.subscribe.push(watcher)
        }
        notify(){
            this.subscribe.forEach(item=>{
                item.update()
            })
        }
    }
    const dep = new Dep()
    // 订阅者
    class Watcher {
        constructor(name) {
            this.name = name;
        }
        update() {
            console.log(this.name + '发生update');
        }
    }
    const w1 = new Watcher('张三')
    dep.addSub(w1)
    const w2 = new Watcher('李四')
    dep.addSub(w2)
    const w3 = new Watcher('王五')
    dep.addSub(w3)
    dep.notify()
```

### 双向绑定

1.什么是双向绑定

```
使用js代码更新model层的数据，view自动更新；用户更新view的数据，model的数据也自动被更新；
数据变化后更新视图【数据绑定】
视图变化后更新数据【DOM事件监听】
```

2.双向绑定的原理

```
viewmodel层有两个监听器：
监听器（Observer）：对所有数据的属性进行监听
解析器（Compiler）：对每个元素节点的指令进行扫描解析,根据指令模板替换数据,以及绑定相应的更新函数
```

3.双向绑定的实现

```
1.new Vue(el,data),对data进行处理，整个过程发生在Observer中。Object.defineReactive为每一个key创建一个Dep(发布者)实例。
2.同时对模板进行解析，找到动态绑定的数据，从data中获取数据初始化视图，发生在Complier中。当初始化遇到一个key时，触发了get方法，创建一个watcher,同时定义更新函数update()，将此watcher加入到对应key的Dep中。
3.一旦data的key值发生变化，触发了set方法，通过Dep.notify()通知所有的watcher执行更新函数update(),update中执行run(),触发了Compile中绑定的回调函数。
```

<img src="C:\Users\halo\Desktop\前端知识点.assets\6c155f92bf101d7f3474c8db1dc5a5f2ceb4162adcce9c8ed358cb008b64ac2a92d08620afbe4bc5b07a8d61e4550181.png" alt="img" style="zoom: 75%;" />

### Vue的常见内置指令

```
v-html:会将绑定的变量中的html标签解析
v-text:与{{}}类似，但是会替换标签中的原文本
	<span v-text='text'>123</span>
	<span>{{text}}123</span>
v-for：优先级比v-if高，所以不要一起使用，用计算属性解决
v-pre:不解析该标签下的插值语法
```

### V-for为什么要加key?并且key最好选用具有唯一性的

避免diff算法就地复用带来的问题

![image-20211110211608753](C:\Users\halo\Desktop\前端知识点.assets\image-20211110211608753.png)

### diff算法

```
如果数据发生更新就重新生成dom树，并渲染页面，开销很大。
虚拟dom将真实的dom抽取出来，每个节点都是对象


1.先检查两个节点值不值得比较，sameVnode（）：key,tagname,是否为注释节点，都有data属性且input的type相同。
	若不同直接Vnode替换oldNode
	若相同就需要执行patchNode（），转到第2步
2.patchNode（）,检查两个node是否指向同一个对象，若相同直接return，否则检查内部是否都只有文本且是否相同。否则检查两个Node的孩子节点：
	Vnode有    oldNode无：直接添加即可
	Vnode无    oldNode有：直接删除即可
	两个都有子节点：执行updateChildren（）算法，利用头尾指针比较，递归调用diff算法
```

![img](C:\Users\halo\Desktop\前端知识点.assets\9e3c68d1b0884d9ca0f8ffc5ee64a28e~tplv-k3u1fbpfcp-watermark.image)

### 虚拟dom如何到真实dom

```js
let vnode = {
  tagname: 'div',
  attrs: {
    id: 1,
    class: 'active'
  },
  content: 'hello'
}
// 虚拟DOM到真实DOM的大概转换过程 
let div = document.createElement(vnode.tagname) 
for (let key in vnode.attrs) {
  div.setAttribute(key, vnode.attrs[key])
}
div.innerHMTL = vnode.content
document.querySelector('body').appendChild(div);
```



### 生命周期

```
常用的生命周期钩子：
				1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。
				2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。
关于销毁Vue实例
				1.销毁后借助Vue开发者工具看不到任何信息。
				2.销毁后自定义事件会失效，但原生DOM事件依然有效。(click之类的原生事件依然会被调用)
			    3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。
```

### nextTick()

```
this.$nextTick(()=>{})//在下一次dom更新之后执行回调，因为vue中的dom更新是异步的。
```

<img src="C:\Users\halo\Desktop\前端知识点.assets\20190110141453331.png" alt="img" style="zoom: 67%;" />

<img src="C:\Users\halo\Desktop\前端知识点.assets\20190110141551420.png" alt="img" style="zoom:67%;" />

```
this.msg被修改了，但是dom需要执行完成后才会更新，所以this.$refs.msgDiv的innerHTML并没更新为最新的this.msg，所以msg1和msg3依然是之前的内容，而msg2使用nexttick在dom更新完执行回调，this.$refs.msgDiv的innerHTML更新为最新的了，所以this.msg2内容被更改。
```

<img src="C:\Users\halo\Desktop\前端知识点.assets\20190110141753359.png" alt="img" style="zoom:67%;" />

使用场景

```
1.生命周期的created()钩子函数中对dom的操作，此时dom并没有被渲染。
2.更改数据后想立即基于新的dom做点什么，新的dom更新是异步的。
```

原理

```
vue观察到数据变化，会开启队列，把在同一个事件循环当中观察到的watcher推送进这个队列，在下一个事件循环时，vue会清空队列，并进行必要的dom更新。
```



### 路由守卫

路由的执行顺序：

​	beforeRouteLeave(上一组件独享后置守卫)-beforeEach(全局前置守卫)-beforeEnter(路由独享守卫)-beforeRouteEnter（组件独享前置守卫）-导航被确认-afterEach(全局后置守卫)-Dom更新-beforeRouteEnter(next回调函数)

全局守卫：每次路由切换都会执行 

```
	可以写在main.js中
	全局前置守卫：
	router.beforeEach((to,from,next)=>{//去哪个路由，从哪儿去，放行函数
	检查to路由是否需要权限控制，再判断localstorage里的信息是否正确再放行
	
	全局后置守卫：
	router.afterEach((to,from)=>{
	放行后执行，比如我们跳转后需要修改当前网页的名称
```

独享守卫：单个路由的独享守卫

```
beforeEnter(to,from,next){//
```

组件独享守卫：只负责进入这个组件

```
//进入守卫：通过路由规则，进入该组件时被调用
beforeRouteEnter (to, from, next) {
},
//离开守卫：通过路由规则，离开该组件时被调用
beforeRouteLeave (to, from, next) {
}
```

### 路由的两种模式

1.hash模式 默认

```
hash就是#+后面的内容，hash虽然出现URL中，但不会导致浏览器对服务器发起请求，因此就不会刷新页面，只是前端路由进行跳转操作,即单页面应用。
hash的改变会触发hasChange这个事件来实现更新页面部分内容的操作。
hash创建hashHistory对象，有两个API实现单页面应用：
	HashHistory.push(route)将新的路由添加到历史记录栈的栈顶，
	HasHistory.replace(route)将历史记录栈的栈顶路由替换为新的路由。
特点：兼容性好但是不美观。若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。
```

<img src="C:\Users\halo\Desktop\前端知识点.assets\6bb04eeb1898484db4251a64b0f79c36.png" alt="img" style="zoom: 67%;" />

2.history模式

```
hash创建HTML5History对象
修改浏览器历史记录后会触发popstate事件，我们可以通过监听popstate事件
主要方法有back(), forward(), go()来读取浏览器路由历史并控制跳转
HTML5新增pushState(), replaceState()2个方法来修改历史信息，调用这两个方法修改历史信息后，虽然当前URL改变了，但浏览器不会立即发送请求该URL，这就满足单页面应用”更新视图但不重新请求页面“的需求

特点：
history模式则会将URL修改得就和正常请求后端的URL一样，如后端没有配置对应/user/id的路由处理，则会返回 404 错误。
history模式怕啥,不怕前进，不怕后退，就怕刷新，（如果后端没有准备的话）,因为刷新是实实在在地去请求服务器的。
在history模式下，你可以自由的修改path。history模式最终的路由都体现在url的pathname中，这部分是会传到服务器端的，因此需要服务端对每一个可能的path值都作相应的映射。
比hash模式美观，兼容性比hash的差，应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。
```

### 路由传参

**query传参和获取**

可以使用path和name进行跳转

```vue
<!-- 跳转并携带query参数，to的字符串写法 -->
<router-link :to="/home/message/detail?id=666&title=你好">跳转</router-link>
				
<!-- 跳转并携带query参数，to的对象写法 -->
<router-link 
	:to="{
		path:'/home/message/detail',
		query:{
		   id:666,
            title:'你好'
		}
	}"
>跳转</router-link>
  

<ul>
    <li>消息编号:{{ $route.query.id }}</li>
    <li>消息标题:{{ $route.query.title }}</li>
  </ul>

```

**params传递参数和获取**

只能使用name进行传参，并且参数成为路径的一部分

1. params是路由的一部分,必须要在路由后面添加参数名。query是拼接在url后面的参数，没有也没关系。
2. params一旦设置在路由，params就是路由的一部分，如果这个路由有params传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。
3. 使用params不在路由配参数跳转，只有第一次进入页面参数有效，刷新页面参数就会消失。

```
//params传参 使用name
this.$router.push({
  name:'second',
  params: {
    id:'20180822',
     name: 'query'
  }
})

//params接收参数
this.id = this.$route.params.id ;
this.name = this.$route.params.name ;

//路由

{
path: '/second/:id/:name',
name: 'second',
component: () => import('@/view/second')
}
```



### Vuex

State:定义了应用状态的数据结构，可以在这里设置默认的初始化状态。

Getter:允许组件从Store中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。

```js
// 可以认为是 store 的计算属性
  getters: { // 可以认为是 store 的计算属性
    // getters里面的方法 也会有state参数
    powerCounter(state) {
      return state.counter * state.counter
    },
    // 找出多于20岁的学生 
    // filter(回调函数(当前元素的值))
    more20stu(state) {
      return state.students.filter(s => s.age > 20)
    },
  }
    <h2>{{ $store.getters.powerCounter }}</h2>
    <h2>{{ $store.getters.more20stu }}</h2
```

Mutation:是唯一更改 store 中状态的方法，且必须是同步函数。

```js
    addcount(state, count) { // 默认就有个state参数，不用通过this.state
      state.counter += count
    },
        
    add5(count){
      this.$store.commit('addcount',count)
    },
```

Action:

用于提交 mutation，而不是直接变更状态，可以包含任意异步请求。

```js
mutations:{
         updateInfo(state) {
              state.info.name = 'coderwhy'
        }
    },
 actions:{
     // 默认参数 context: 上下文 现在先理解成store
     aUpdateInfo(context, payload) {
         setTimeout(() => {
             context.commit('updateInfo')
             console.log(payload.message);
             payload.success() // 调用回调 告诉外面已经成功
         }, 1000)
     },
 }
	// this.$store.commit('updateInfo')  // 这样没有经过actions
      // 异步修改信息 actions
      // this.$store.dispatch('aUpdateInfo',"我是携带的信息");// 携带一个参数
```

Module:

允许将单一的 Store 拆分更多个 store 且同时保存在单一的状态树中。



## HTML5/浏览器

### Cookie,Session, token

cookie和session配合使用   ，跨域很麻烦，适合服务器渲染

- Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。

- 当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。

- 当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制

  ```
  共同点：都是用来跟踪浏览器用户身份的会话方式
  
  区别：
  - cookie数据保存在浏览器，session数据保存在服务器
  - cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑安全性使用session
  - session会在一定时间内保存在服务器上，当访问增多会占用服务器性能，考虑性能使用cookie
  ```




### Token

```
1.认证成功后，会对当前用户数据进行加密，生成一个加密字符串token，返还给客户端（服务器端并不进行保存）
2.浏览器会将接收到的token值存储在Local Storage中，（通过js代码写入Local Storage，通过js获取，并不会像cookie一样自动携带）
3.再次访问时服务器端对token值的处理：服务器对浏览器传来的token值进行解密，解密完成后进行用户数据的查询，如果查询成功，则通过认证，实现状态保持，所以，即时有了多台服务器，服务器也只是做了token的解密和用户数据的查询，它不需要在服务端去保留用户的认证信息或者会话信息，这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利，解决了session扩展性的弊端。
```



### **cookie，localStorage，sessionStorage的共同点和区别**

```
共同点：
都是前端本地存储的方式，均保存在浏览器端且同源

区别：
- 数据和服务器之间的交互方式
  cookie可以在客户端和服务器之间来回传递
  localStorage和sessionStorage不会主动把数据发送给服务器，仅在本地保存。
- 生命周期
  cookie在设置的有效期到期前都有效，默认是关闭浏览器后失效
  sessionStorage仅在当前网页会话下有效，关闭页面或浏览器后失效
  localStorage除非被手动清除，否则始终有效，永久保存
- 存放数据大小
  cookie存储容量较小，一般只有4KB
  localStorage和sessionStorage可以保存5MB的信息
- 作用域
  cookie和localStorage在所有同源窗口都是共享的
  sessionStorage不在不同的浏览器窗口中共享
```

### Token放在cookie和sessionStroage、localStroage中区别

```
cookie:浏览器得到后每次发起请求都会自动携带cookie，如果访问a网站，得到了返回的cookie，再访问一个恶意网站B，b收到		请求后，携带cookie向a发起恶意攻击请求，就能执行该代码了。（CSRF(跨站请求伪造)）
token：浏览器发起请求并不会自动携带，而需要手动添加到请求头中，所以一般放在sessionStroage、localStroage中
```

###  CSRF和XSS

#### csrf(跨站身份伪造)

```
 CSRF(跨站身份伪造)：当用户登陆状态时，访问恶意网站，恶意网站携带cookie去执行恶意代码；
 	防御方式：使用验证码，使用token，检查https的referer（检查是从哪儿跳转过来的，referer是写错了实际是referrer推荐人）
```

#### xss（跨站脚本攻击）

```
 XSS（跨站脚本攻击）：攻击者通过在目标网站上注入恶意脚本来获取敏感信息
 本质：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。输入值的转义不完全
 类型：
 	存储型：攻击者将恶意的代码, 提交到数据库中，服务器从数据库中获取的内容拼接成html, 返回给浏览器用户打开页面, 			混入其中的恶意代码被浏览器执行，获取的关键信息发送给攻击者。  场景: 用户发表评论, 论坛发帖, 用户私信等
 	反射型：攻击者构造包含恶意代码的URL,用户打开后，服务器将恶意代码从URL中取出，拼接在HTML中返回给浏览器。浏览			器接收到响应后解析执行，混在其中的恶意代码也被执行。           场景: 网站搜索, 分享链接, 恶意邮件等
 	dom型：浏览器解析机制导致的漏洞，服务器不参与。攻击者构造包含恶意代码的URL,用户打开后，前端js取出 URL 中的恶			意代码并执行。
防御方式：
    在响应http头部配上set-cookie，其中
    	httponly：该属性会禁止JS脚本使用document.cookie来访问cookie
    	secure：该属性告诉浏览器仅在请求为HTTPS的时候才发送cookie
    	Set-Cookie: <cookie-name>=<cookie-value>; Secure;HttpOnly
    进行特殊字符过滤；对用户的输入进行检查
```

### token为什么可以防止CSRF

```
第三方网站只是使用cookie，而不能获取到cookie中的内容。服务器通过生成token,存在cookie中发送给浏览器，浏览器将cookie中的token存在localstorage中，每次请求在请求体或者请求参数中设置token。而第三方网站时是获取不到这个token，所以不能在请求体中设置。
服务器的验证规则就是从请求体（POST）或者请求参数（GET）中获取设置的 token，认证成功后，会对当前用户数据进行加密，生成一个加密字符串token，返还给客户端（服务器端并不进行保存然后和 Cookie 中的 token 进行比较，一致之后才执行请求。
```



### 强缓存和协商缓存

```
强缓存：客户端不发送请求给服务器，直接使用浏览器的缓存，返回状态码200(比如expires,cache-control)
协商缓存：客户端发送请求，客户端告知可以使用之前的缓存,返回状态码304（if-none-matched ----etag）和(if-modified-since ----  last-modified)
```



### get和post区别

```
get:也能实现增删改，参数放在url中，只发送一个tcp数据包，将data和header一起发过去，服务器相应200，get请求类似于查找工作，不用每次都与数据库连接

post:参数放在request body中，发送两个tcp数据包，先发送header,响应100，浏览器再发送data,，post一般实现增删改，需要与数据库交互。
```



### 跨域

谁在拦截？

```
实际上是浏览器拦截，已经获取到了服务器的资源，甚至返回的都是200状态，但是浏览器的同源策略禁止执行
```

什么是跨域？

```
非同源就是跨域，所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。为了防止XSS、CSFR等攻击
```

### 如何解决跨域请求？

JSONP

![image-20220427171132012](C:\Users\halo\Desktop\前端知识点.assets\image-20220427171132012.png)

```
以下这三个标签加载资源路径是不受束缚的
1、script标签：<script src="加载资源路径"></script>
2、link标签：<link herf="加载资源路径"></link>
3、img标签：<img src="加载资源路径"></img>

利用script的src去发送请求，将一个方法名callback传给后端，后端拿到这个方法名，将所需数据，通过字符串拼接成新的字符串callback(所需数据)，并发送到前端，前端接收到这个字符串之后，就会自动执行方法callback(所需数据)。
```



cors

![image-20220427171230385](C:\Users\halo\Desktop\前端知识点.assets\image-20220427171230385.png)

		前端跨域访问到后端，后端开启Cors，发送Access-Control-Allow-Origin: 域名 字段到前端（其实不止一个），前端浏览器判断Access-Control-Allow-Origin的域名如果跟前端域名一样，浏览器就不会实行跨域拦截，从而解决跨域问题。
	   res.writeHead(200, {
	        //设置允许跨域的域名，也可设置*允许所有域名
	        'Access-Control-Allow-Origin': 'http://127.0.0.1:5500',
	        //跨域允许的请求方法，也可设置*允许所有方法
	        "Access-Control-Allow-Methods": "DELETE,PUT,POST,GET,OPTIONS",
	        //允许的header类型
	        'Access-Control-Allow-Headers': 'Content-Type'
	    })


Node接口代理

![image-20220512090609905](C:\Users\halo\Desktop\前端知识点.assets\image-20220512090609905.png)

```
同源策略它只是浏览器的一个策略而已，它是限制不到后端的，也就是前端-后端会被同源策略限制，但是后端-后端则不会被限制，所以可以通过Node接口代理，先访问已设置Cors的后端1，再让后端1去访问后端2获取数据到后端1，后端1再把数据传到前端.
```



### 输入URL，到页面呈现经历的过程

```
1.需要将域名解析为网络中的IP地址（浏览器缓存-系统缓存-路由器缓存-hosts文件-域名服务器）
2.ip+端口得到一个http请求，经过TCP包装，通过传输层网络层物理层发送到了服务器，服务器返回相应的HTML。
3.浏览器得到后，开始构建dom树，遇到图片音视频并行下载，遇到js会只下载js阻塞dom树的构建;根据外部样式、内部样式、内联样式构建CSSOM树，然后和dom树合并成渲染树。目的是排除非视觉节点，比如script、meta标签和排除display为none的节点
4.确定页面的布局，元素的位置和尺寸渲染页面，展示给用户
5.涉及到缓存机制。
```



### HTML5新特性

```
新增标签：header,main,footer
input新增类型标签：email,tel,date,week,time   placeholder(默认提示文本) autofocus自动获取焦点
可以使用sessionStorage 和localStorage
拖放API(dragstart,drag,dragenter)
```

### Doctype标签

```
<!DOCTYPE> 声明位于文档中的最前面的位置，处于 <html> 标签之前。
它是用来告知 Web 浏览器页面使用了哪种 HTML 版本。
告诉浏览器以什么模式渲染页面：严格模式（以浏览器可以支持的最高标准运行）混杂模式（兼容老版本的浏览器，防止页面布局出现错误）
```

### meta标签
<meta> 标签提供了 HTML 文档的元数据。元数据不会显示在客户端，但是会被浏览器解析。
通常用于指定网页的描述，关键词，文件的最后修改时间，作者及其他元数据。
通常编写在在head标签中。

```html
实例 1 - 定义文档关键词，用于搜索引擎：
<meta name="keywords" content="HTML, CSS, XML, XHTML, JavaScript">
实例 2 - 定义web页面描述：
<meta name="description" content="Free Web tutorials on HTML and CSS">
实例 3 - 定义页面作者：
<meta name="author" content="Hege Refsnes">
实例 4 - 定义文档的字符编码。
<meta charset="UTF-8">
实例5 - viewport 属性用于移动端显示优化的。
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```



### WebSocket

```
HTML5新增的协议，使得服务器也可以主动向客户端发起通信
```

### Http2.0

```
1.内容比http1.0更安全，因为是基于https的，是基于ssl加密的http协议，并且根据http2.0的特性，避免单纯使用https的性能下降。
2.二进制分帧：http1.0基于文本，http2.0将传输信息分割为更小的消息和帧，用二进制格式编码，让协议有了更多扩展性，可以用帧来传输数据和指令
3.多路复用：因为是基于二进制分帧，将消息分解后交错的发送出去，接收方根据id将其重新组合起来。
4.服务器推送：服务器根据请求可以提前返回多个响应，推送额外的资源给客户端。
```

### 事件循环EventLoop

<img src="C:\Users\halo\Desktop\前端知识点.assets\1460000016278118" alt="img" style="zoom: 80%;" />

```
macrotask(宏任务)：用来保存一些异步函数的回调
	setTimeout    setInterval     setImmediate (Node独有)    requestAnimationFrame (浏览器独有) 
	I/O  UI rendering (浏览器独有)    http.get
microtask(微任务)：用来保存另一些异步函数的回调
	process.nextTick (Node独有)    Promise    Object.observe    MutationObserver
```

步骤：

​	1.执行全局Script同步代码，有些是同步有些是异步，执行完成，调用栈会清空

​	2.执行微任务队列中队首的回调任务，放入调用栈中执行，执行完成后microtask的长度减1

​	3.继续调用微任务队列队首的回调，将该队列中的所有任务都执行完，若这个过程中产生了新的microtask，放入队尾，保证也在这个周期内执行完毕。

​	4.微任务队列中的回调任务执行完毕后，取出宏任务队列中队首的任务，放入回调栈中执行，执行完后重复2-4直到所有的任务都执行完成

两个例子：

```js
console.log(1);

setTimeout(() => {
  console.log(2);
  Promise.resolve().then(() => {
    console.log(3)
  });
});

new Promise((resolve, reject) => {
  console.log(4)
  resolve(5)
}).then((data) => {
  console.log(data);
})

setTimeout(() => {
  console.log(6);
})

console.log(7);
//1 4 7 5 2 3 6



console.log(1);

setTimeout(() => {
  console.log(2);
  Promise.resolve().then(() => {
    console.log(3)
  });
});

new Promise((resolve, reject) => {
  console.log(4)
  resolve(5)
}).then((data) => {
  console.log(data);
  
  Promise.resolve().then(() => {
    console.log(6)
  }).then(() => {
    console.log(7)
    
    setTimeout(() => {
      console.log(8)
    }, 0);
  });
})

setTimeout(() => {
  console.log(9);
})

console.log(10);
//1 4 10 5 6 7 2 3 9 8
```



### 浏览器进程和线程

```
进程：以前的单进程浏览器其中有其他线程-网络线程-页面线程，导致同时只能有一个模块执行。
进程之间是相互隔离的，一个进程崩溃不会影响其他的进程，通信使用进程间通信（IPC）机制。

目前多进程：	渲染进程：每个页面都会有一个渲染进程，免得单个page崩掉影响其他页面。
			浏览器进程：最核心的进程，负责每个page创建和销毁，前进后退功能
			插件进程：用来加载第三方插件，避免第三方插件crash崩掉，影响整个。
			GPU进程：负责3D绘制和硬件加速
	浏览器内核就是渲染进程：多线程
		GUI渲染线程：负责渲染浏览器页面，发生重绘时执行。
		定时器触发线程：定时器不能放到js中，js是单线程的，当发生线程阻塞影响计时器。
		事件触发线程：事件被触发，添加到队列的队尾
		异步请求线程：XMLHttpRequest的readyState变化后执行回调函数，添加到待处理队列中
		JS引擎线程：执行JS脚本，运行代码，对DOM进行操作，不能与GUI线程同时运行。
```

JS为何设置为单线程？

```
假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
```

WebWorker 多线程

```
创建 Worker 时， JS 引擎向浏览器申请开一个子线程(子线程是浏览器开的，完全受主线程控制，而且不能操作DOM)
JS 引擎线程与 worker 线程间通过特定的方式通信(postMessage API，需要通过序列化对象来与线程交互特定的数据)
所以 WebWorker 并不违背 JS引擎是单线程的 这一初衷，其主要用途是用来减轻cpu密集型计算类逻辑的负担。
```

### Web开发模式

1.服务器端渲染SSR

​	服务器通过拼接字符串直接带有html标签的页面，客户端不需要使用ajax额外请求页面的数据。

```
优点：前端耗时短，无需请求额外的数据；响应的是整个HTML页面，有利于爬虫爬取信息，因此有利于SEO。
缺点：占用了服务器资源，不利于前后端分离，开发效率低；

为何有利于SEO?	
	SEO是搜索引擎的策略，负责采集网站信息，建立索引表，在用户查询的时候根据关键字和相关度返回列表，其内部的网络机器人一直在爬取网络中的信息。假如采用前后端分离开发的网站，爬虫爬取内容还需要通过js请求等服务器返回之后，所以可能根本爬不到数据。而服务器渲染返回的就是已经带数据的页面，爬虫能够获取到有用的信息。
```

2.前后端分离：

​	依赖于Ajax技术，后端负责api接口，前端使用ajax调用。

```
优点：开发体验好，前端专注页面开发，后端专注接口开发。用户体验好，页面局部刷新；减轻服务器压力，页面在浏览器生成。
缺点：不利于SEO，完整的页面是在浏览器中拼接完成的，利用框架的SSR(server side render)解决。
```

如何选择

- 企业级网站，主要功能是展示，没有复杂交互，且需要良好的 SEO，可考虑服务端渲染
- 后台管理项目，交互性强，无需考虑 SEO，可使用前后端分离
- 为同时兼顾首页渲染速度和前后端分离开发效率，可采用首屏服务器端渲染+其他页面前后端分离的开发模式

### 浏览器垃圾回收机制

一.标记清除

1. 第一阶段是标记，从一个 GC root 集合出发，沿着「指针」找到所有对象，将其标记为活动对象。

2. 第二阶段是清除，将内存中未被标记的对象删除，释放内存空间。

   <img src="C:\Users\halo\Desktop\前端知识点.assets\image-20220427172156832.png" alt="image-20220427172156832" style="zoom: 67%;" />

二.复制算法

1. 将整个空间平均分成 from 和 to 两部分。
2. 先在 from 空间进行内存分配，当空间被占满时，标记活动对象，并将其复制到 to 空间。
3. 复制完成后，将 from 和 to 空间互换。

<img src="C:\Users\halo\Desktop\前端知识点.assets\image-20220427172253112.png" alt="image-20220427172253112" style="zoom: 50%;" />

三.引用计数

1. 实时统计指向对象的引用数（指针数量）。

2. 当引用数为 0 时，实时回收对象。

   <img src="C:\Users\halo\Desktop\前端知识点.assets\image-20220427172420065.png" alt="image-20220427172420065" style="zoom:67%;" />

四.标记-压缩

1. 从一个 GC root 集合出发，标记所有活动对象。
2. 将所有活动对象移到内存的一端，集中到一起。
3. 直接清理掉边界以外的内存，释放连续空间。

<img src="C:\Users\halo\Desktop\前端知识点.assets\image-20220427172808866.png" alt="image-20220427172808866" style="zoom:67%;" />

### JS的垃圾回收机制

1.栈中的垃圾回收

```
JavaScript 在执行函数时，会将其上下文压入栈中，ESP 上移，而当函数执行完成后，其执行上下文可以销毁了，此时仅需将 ESP下移到下一个函数执行上下文即可，当下一个函数入栈时，会将 ESP 以上的空间直接覆盖。
```

2.堆中的垃圾回收

```
JavaScript 堆中垃圾数据回收就使用到了分代收集的思想，引擎将堆空间分为 「新生代(young-space)」 和 「老生代(old-space)」 ，并且对两个区域实施不同的垃圾回收策略。
1.新生代：新创建的小的对象都会被分配到该区域，该区域的垃圾回收会比较频繁
	使用复制算法进行垃圾回收
2.老生代：存放生存时间长的对象和大的对象
	使用标记-压缩算法，JavaScript 是单线程运行的，在执行垃圾回收逻辑时，后续的脚本任务需要等垃圾回收完成后才能继	续执行。若堆中的数据量非常大，一次完整垃圾回收的时间会非常长，将导致应用的性能和响应能力都直线下降。
```

### 内存泄漏和内存溢出

```
内存泄漏：程序申请内存后，无法释放已申请的内存空间，多个内存泄漏堆积后会引起内存溢出。
内存溢出：程序申请内存时，没有足够的内存供申请者使用。
```



### document.documentElement对象

```
document.documentElement.clientWidth
获取浏览器窗口文档显示区域的宽度，不包括滚动条。
                                          //width+padding,随着窗口的缩放而改变
document.documentElement.clientHeight
获取浏览器窗口文档显示区域的高度，不包括滚动条
```

```
document.documentElement.offsetWidth
获取DOM文档的根节点html元素对象的宽度，即offsetWidth=width+padding+border，不包括margin。随着窗口的缩放而改变
                                          //随着窗口的缩放而改变
document.documentElement.offsetHeight
获取DOM文档的根节点html元素对象的高度，即offsetHeight=height+padding+border，不包括margin。
```

```
document.documentElement.scrollWidth
获取html元素对象内容的实际宽度，即html元素对象的滚动宽度。
									//可能会随着窗口的缩放而改变
document.documentElement.scrollHeight
获取html元素对象内容的实际高度，即html元素对象的滚动高度。
```

```
document.documentElement.clientLeft
获取html元素对象的左边框的宽度。

document.documentElement.clientTop
获取html元素对象的上边框的宽度。
```

```
document.doucmentElement.offsetLeft
获取html元素对象相对于整个页面文档的位置，也就是html元素的margin。

document.documentElement.offsetTop
获取html元素对象相对于整个页面文档的位置，也就是html元素的margin。
```

```
document.documentElement.scrollLeft
设置或获取页面文档向右滚动过的像素数。

document.documentElement.scrollTop
设置或获取页面文档向下滚动过的像素数。
```



### 移动端适配

**1.CSS3媒体查询适配**

不同的屏幕宽度加载不同的css代码 	通过查询设备的宽度来执行不同的css代码，最终达到界面的配置

    @media only screen and (max-width: 374px) {
      /* iphone5 或者更小的尺寸，以 iphone5 的宽度（320px）比例设置样式*/
    }
    @media only screen and (min-width: 375px) and (max-width: 413px) {
      /* iphone6/7/8 和 iphone x */
    }
    @media only screen and (min-width: 414px) {
      /* iphone6p 或者更大的尺寸，以 iphone6p 的宽度（414px）比例设置样式 */
    }
**2.rem布局（）**
	rem(root em)是一个相对单位，相对于html元素字体大小font-size计算倍数
 	比如，根元素(html)设置font-size=12px，非根元素设置width：2rem；，转换成px就是24px。

```js
<script>
    // 设置html字体大小
    // 切图的时候算(以二倍图为例)
        // 实际的大小 = 图片大小/2/rem;
    // js:
        // 基准rem/基准分辨率 = 新rem/新的分辨率
        // 50/375 = 新rem/新的分辨率
        // 新rem = 基准rem/基准分辨率*新的分辨率clientWidth;
        
    // 设置rem(设置html的字体大小)
    document.documentElement.style.fontSize = 50 / 375 * document.documentElement.clientWidth + 'px';
    
    // 监听resize事件(改变浏览器大小时，设置新的rem)
    window.onresize = function (){
        document.documentElement.style.fontSize = 50 / 375 * document.documentElement.clientWidth + 'px';
    }
</script>
```

**3.以天猫首页为代表的flex弹性布局**

**4.基于屏幕百分比的rem布局**

```
这种方式是给元素设置百分比，例如2个div想占满宽度100%，那么一个div设置宽度为50%，这样不固定宽度，使得在不同的分辨率下都能达到适配。
```



### 前端优化/Web性能优化

```
缓存：HTTP缓存机制、离线数据缓存localStorage
渲染：使用外部JS和CSS、加载顺序（将CSS样式表放在顶部，JS脚本放在底部）、图片懒加载
```



### 回流/重排 和重绘问题

```
重排/回流（reflow）：部分或整个渲染树需要重新分析并且节点尺寸需要重新计算。
重绘(repaint)：由于节点的几何属性发生改变或者样式发生改变，屏幕上的部分内容需要更新。
引起重排重绘的原因可能的原因：
    浏览器初始化窗口(无法避免)
    添加或删除可见的DOM元素
    移动或者给页面中的DOM节点添加动画
    添加一个样式表，调整样式属性
    用户行为，如调整窗口大小、改变字号、滚动等
避免的方法（尽量避免对渲染树进行操作）：
	改变元素的className（静态改变）而不是style
	批量改变和表现DOM：复制即将更新的节点，在副本上操作，然后将旧的节点和新的节点交换；
	通过display：none隐藏元素，添加足够多的变更，通过display显示（只触发两次重排重绘）。
	使用cssText（动态改变）一次性改变属性,var el = document.querySelector(’.el’);
		el.style.cssText = ‘border-left: 1px; border-right: 2px; padding: 5px;’;
	对于多次重排的元素，比如动画，使用绝对定位使其脱离文档流，不影响其他元素。
	对resize、scroll 等行为进行防抖/节流处理
```

## 计算机网络

<img src="C:\Users\halo\Desktop\前端知识点.assets\网络模型.jpg" alt="img" style="zoom: 50%;" />

OSI:注重通信协议必要的功能是什么     TCP/IP:更关心在计算机上实现协议应该开发哪种程序

### 应用层的网络协议

```
FTP：文本传输协议
SMTP：简单邮件传输协议
TELNET：Internet远程登录服务的标准协议和主要方式
HTTP：超文本传输协议

TFTP：简单文件传输协议
DNS：域名系统
SNMP：简单网络管理协议
NFS：网络文件系统
```

### TCP UDP

TCP传输控制协议

```
面向连接可靠的，能够保证数据无差错，不丢失，不重传，按序的到达，只能一对一，面向字节流，对数据可靠性要求很高使用，比如浏览器和服务器的连接。对应的应用层的协议主要有SMTP,TELNET,HTTP,FTP 等。
```

UDP用户数据协议

```
无连接不可靠的，只能尽最大可能交付数据，可以一对一或者一对多，面向报文，使用于对高速传输数据和实时性要求高的场景，比如视频会议。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。
```

### 为什么TCP比UDP可靠？

```
连接方面：TCP在传输数据前需要建立连接，会同步双方的序列号，确认号，窗口大小等等。
在传输过程中：有了丢包或者延时，发送端都有一套重传机制。
```



### 三次握手

<img src="C:\Users\halo\Desktop\前端知识点.assets\aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA1MTEwNDA1NjY2" alt="img" style="zoom: 67%;" />

```
1.客户端发起请求报文：同步号SYN=1,序列号seq=x,此时不能携带数据，客户端进程进入了 SYN-SENT（同步已发送状态）状态。
2.服务器接收到，发起确认报文：SYN=1,seq=y,确认号ack=x+1,ACK=1，此时不能携带数据，服务器进程进入了SYN-RCVD（同步收到）状态
3.客户端收到后也许要发起确认报文：ack=y+1，seq=y+1,ACK=1，此时可以携带数据，客户端进入ESTABLISHED（已建立连接）状态
4.服务器收到客户端的确认后也进入ESTABLISHED状态。

为什么要第三次客户端还需要确认？
	当第一次客户端发起请求报文，网络堵塞，于是它再发一个，并且完成了连接并释放了。   然后网络畅通，第一次发送的到了，服务器得到了并且返回，这时候客户端能够判别是滞留的，就不用建立起连接，免得浪费资源。
```

### 四次挥手

<img src="C:\Users\halo\Desktop\前端知识点.assets\TCP挥手.png" alt="img" style="zoom:67%;" />

```
1.客户段发起连接释放报文，FIN=1,seq=u（前面传送的数据最后一个序列号+1）,客户端进入FIN-WAIT-1（终止等待1）状态
2.服务器发送确认报文，ACK=1,ack=u+1,seq=v  ,但是只是不再接收客户端数据，自己还要发送未发完的数据，服务端就进入了CLOSE-WAIT（关闭等待）状态。
3.客户端确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态
4.等到服务器的数据发完了，发送连接释放报文，FIN=1,seq=w(这时候已经与v不同了)，ack=u+1,ACK=1，服务器就进入了LAST-ACK（最后确认）状态
5.客户端发送确认关闭报文，ACK=1,ack=w+1,seq = u+1,状态变为TIME-WAIT（时间等待）状态，然后再等2*（最长报文段寿命）再关闭，变为CLOSED状态.
6.服务器收到确认请求就会直接变为CLOSED状态。

为什么要等2*最长报文段寿命？
	1.保证最后的确认能够达到服务器，若因为丢失，服务器一段时间没有收到会重复第3步，这样客户端能够重启2*MSL
	2.避免之前发送的报文重新传给了服务器，经过2*MSL,所有报文段都消失了
为什么要四次挥手？
	服务器收到客户端发送的关闭请求，只是代表自己可以不再接收数据了，但是可能服务器还有未发送完的数据，所以先发送确认，等自己的数据发完了，再发一个关闭报文，导致比三次多了一次。
```



## 操作系统

### 进程

进程的调度机制：排队器，分派器，上下文切换器

进程的调度方式：非抢占式，抢占式

调度算法：

```
1.先来先服务    2.短作业优先    3。优先级调度   4.时间片轮转  5.多级队列反馈
```

### 线程和进程

```
区别：
	1、进程是资源分配调度的最小单位
	2.线程是CPU分配调度的最小单位，
	3.一个程序至少有一个进程，一个进程至少有一个线程，资源分配给进程，同一个进程下所有线程共享该进程的资源。
线程的资源：
	共享：堆、全局变量、静态变量、文件等共用资源
	独享：栈、寄存器
```



### 死锁

发生的原因：资源的不足，分配不当，推进的顺序不当

四个必要条件：

```
1.互斥（一个资源只能被一个进程使用）
2.请求与保持（请求的资源再未完成之前不释放）
3.不剥夺（不能被剥夺）
4.循环等待（进程间形成相互等待资源的关系）
```

## 数据结构

### 数组和链表的区别

```
数组：
	元素的内存地址必须连续
	查找方便，通过下标获取数据
	删除添加不方便，会导致内存地址的重新分配
链表：
	元素的内存地址不用连续，通过元素中的指针来寻找下一个元素
	添加删除方便，只需要更改指针的指向，不需要重新分配内存地址
	查找很麻烦，每次都需要从头遍历，顺序查找
```

### 排序算法

- **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。

- **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 

  <img src="C:\Users\halo\Desktop\前端知识点.assets\849589-20190306165258970-1789860540.png" alt="img" style="zoom: 33%;" />

复杂度分析

<img src="C:\Users\halo\Desktop\前端知识点.assets\849589-20180402133438219-1946132192.png" alt="img" style="zoom:33%;" />

插入排序

```
从第一个元素开始，该元素可以认为已经被排序；
取出下一个元素，在已经排序的元素序列中从后向前扫描；
如果该元素（已排序）大于新元素，将该元素移到下一位置；
重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
将新元素插入到该位置后；
重复步骤2~5。
最好情况o(n),既每次都发现当前元素大于已排序最后一个元素
```

希尔排序

```
先比较距离较远的元素,arr[i]和arr[i+gap]比较，gap初始设为arr.length/2,然后gap =gap/2
```

归并排序

```
把长度为n的输入序列分成两个长度为n/2的子序列；
对这两个子序列分别采用归并排序；
将两个排序好的子序列合并成一个最终的排序序列。
```

堆排序

```
利用堆数据结构，节点的子元素总是小于当前节点
将堆顶与最后一个元素交换，构成新的堆，调整堆，这样每次能够拿到最大的元素
```

计数排序

```
找出数组中最大和最小的元素，（只针对于整数数组），适用于小范围数
新建一数组C，再遍历原数组，元素i出现一次，就在数组C[i]上存储+1
最后再遍历c数组，依次输出，对应的次数-1
```

桶排序

```
计数排序升级版
设置一个定量的数组当作空桶；
遍历输入数据，并且把数据一个一个放到对应的桶里去；
对每个不是空的桶进行排序；
从不是空的桶里把排好序的数据拼接起来。
```

基数排序

```
取得数组中的最大数，并取得位数；
arr为原始数组，从最低位开始取每个位组成radix数组；
对radix进行计数排序（利用计数排序适用于小范围数的特点）；
队列，先进先出
```



### 查找树

1.BST二叉查找树

```
查找复杂度平均O（logn）,最差时退化成单链表，O（n）
插入：与查找一个不存在的一样，既o（logn）
删除：
	1.叶子节点=O（1）     2.只有单个孩子O(1)   3.有两个子树，将右子树的左下叶子移动上来O（logn）
```

2.平衡二叉树

```
牺牲建立平衡来换取查找的效率
所有节点左右子树的高度差<=1
查找的话很平衡：O(N)，不会出现最差情况
插入：需要旋转链表，最多也就一次（单旋或者双旋）代价O(logN),插入需要先找到插入的位置
删除：需要检查平衡情况O(2logN)
```

3.红黑树（Red-Black Tree，RBT）

```
在建立查找结构和查找之间平衡
性质:1.根节点是黑色     
	2.叶子节点是空节点，为黑色      
	3.红色节点的子节点为黑色
	4.任意节点到子节点的黑色节点数相同
	
查找代价：
 	由于红黑树的性质，比AVL查找的性能会差一点，比如最长路径是最短路径的2倍少1，比AVL要逊色一点，基本维持在		  O(logN)左右。
插入代价：
	需要变色和旋转，最多只需要2次旋转。代价O（lonN）
删除代价：
	删除一个节点最多只需要3次旋转。
```

4.B树

```
对于查找数据量大的，文件目录存储，数据库文件索引
```

RBT和AVL的对比

```
结构对比
AVL的结构高度平衡，RBT的结构基本平衡。
查找对比
AVL 查找时间复杂度最好、最坏情况都是O(logN)；RBT 查找时间复杂度最好为O(logN)，最坏情况下比AVL略差。
插入删除对比
（1）AVL的插入和删除结点很容易造成树结构的不平衡，而RBT的平衡度要求较低。因此在大量数据插入的情况下，RBT需要通过旋转变色操作来重新达到平衡的频度要小于AVL。
（2）如果需要平衡处理时，RBT比AVL多一种变色操作，而且变色的时间复杂度在O(logN)数量级上。但由于操作简单，实践中这种变色仍是非常快速的。
（3）当插入一个结点都引起了树的不平衡，AVL和RBT都最多需要2次旋转操作。但删除一个结点引起不平衡后，AVL最多需要logN 次旋转操作，而RBT最多只需要3次。因此两者插入一个结点的代价差不多，但删除一个结点的代价RBT要低一些。
（4）AVL和RBT的插入删除代价主要还是消耗在查找待操作的结点上。因此时间复杂度基本上都是与O(logN) 成正比的。
总体评价：RBT的总体统计性能要好于平衡二叉树
```





## CSS

### 水平居中：

```
对于行内元素: text-align: center;
已知元素宽高：
	width和margin实现。margin: 0 auto;
	父元素position: relative;left:50%,定位元素position:absolute;margin-left: -width/2;
未知元素宽高：
	父元素相对定位，定位元素绝对定位  left:50%;transform:translateX(-50%);
flex布局使用justify-content:center
```

### 水平垂直居中：

```
利用line-height:200px与父容器高度一样实现居中，这种方法适合纯文字类
已知元素宽高：
	通过设置父容器相对定位，子级设置绝对定位，margin:auto;top: 0;left: 0;right: 0;bottom: 0;
	通过设置父容器相对定位，子级设置绝对定位，left: 50%;top: 50%;margin-left: -25px;margin-top: -25px;
未知元素宽高：
	通过设置父容器相对定位，子级设置绝对定位，left: 50%;top: 50%;transform:translate(-50%,-50%);
	弹性布局flex:父级设置display: flex; 子级设置margin为auto实现自适应居中
```

### 模型宽度：

```
盒子模型：
			width = 内部content的宽度   整个盒子的宽度=border+padding+width
IE盒子模型：
			width = content+padding+border 盒子的宽度=width
	设置background-color,生效区域为content+padding
```

### 定位属性positon:

```
fixed:
	基于整个浏览器窗口，脱离文档流，怎样滚动其位置基于视窗都不变，小广告？
relative：
	未脱离文档流，在原位不变，可以通过top,right,bottom,left是元素改变位置，但是自己的原本位置一直在
absolute：
	脱离文档流，相对于最近的相对定位父元素进行定位
sticky：
	先是普通文档流既相对定位，当超过一定的阈值变为固定定位，脱离文档流
```

### display:inline,block,inline-block

```
inline(内联元素)：span,a,input元素等，inline元素只能包含inline元素
	元素不能设置width和height,垂直方向的padding,margin无效，都在一行排列，被内容撑开。
block（块级元素）：div,form,p,h1,h2,block元素可以包含block元素和inline元素，但是p只能包含inline
	单独占据一行，可以设置width,height,padding
inline-block（内联块级）：
	一行排列，但是可以设置宽高;
对于替换元素img是inline元素，本来就有width属性，可以设置宽高，类似还有input
```

### a标签

```
属性：href   tagert(哪个窗口应该被此链接打开)    title
标签样式：link(未访问的样式) visited hover active（按下的样式）  LoVe HAte顺序，否则会失效
```

### BFC块级格式化上下文

```
BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
生成BFC的方式：
	1.浮动元素：float值为left或right
	2.定位元素：position为fixed或absolute的元素
	3.overflow值不为visible，为auto、scroll、hidden的元素
	4.display值为inline-block、table-cell、table-caption、flex、inline-flex的元素

规则：
	在垂直方向上排列，垂直的方向的距离由margin决定，不会与外部的float重叠，BFC的高度包含内部浮动的元素的高度
	
作用：
	1.阻止被外部的浮动元素覆盖
	2.防止相邻的元素margin重叠
	3.防止高度塌陷，父元素高度为0，内部有float元素并设置了高度，可以使父元素为BFC，overflow:hidden
	
	浮动溢出就是高度塌陷：容器的高度为auto，且容器中有浮动元素（float为left或right）时，容器的高度不能自动伸长以适应内容的高度
```

### 弹性布局

```SAS
#main{
  display: flex;
  justify-content: center;   /* 子容器主轴对齐 */
  justify-content: flex-end;/*靠主轴end对齐*/
  justify-content: space-between;/*左右两端对齐，子容器空白相等*/
  justify-content: space-around;/*子容器间距为到底边2倍*/
  justify-content: space-evenly; /*所有间距相等*/
  align-content: center; /*辅轴方向*/
  align-items: center; /*辅轴方向对齐方式*/
  flex-direction: column;/* 改变主轴为列*/
  flex-wrap: nowrap; /*强行等分宽度  不换行 默认*/
  flex-wrap: wrap; /*换行*/

  .box{
    order: 0;/*排列顺序*/
    align-self: center;/*决定单独的组件辅轴排列方式*/
    flex-grow: 0;/*默认0，有剩余宽度是否放大，默认不放大*/
    flex-shrink: 1;/*默认1，空间不够是否缩小，默认缩小*/
    flex-basis: auto;/*定义宽度，但权重比width高*/
    flex: 0 1 auto;/*默认 0 1 auto  是flex-grow flex-shrink flex-basis三个的简写*/
  }
}
```

















## webpack

### 构建流程

```
初始化阶段：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数。 
- 编译构建阶段：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。 
- 输出阶段：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。
```

### Webpack中常见的Loader

```
Loader本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。
loader 支持链式调用，链中的每个loader会处理之前已处理过的资源，最终变为js代码。顺序为相反的顺序执行，即上述执行方式为sass-loader、css-loader、style-loader。
```

### Webpack中常见的Plugin

```
在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。
 html-webpack-plugin：简化 HTML 文件创建 (依赖于 html-loader) 
 uglifyjs-webpack-plugin：不支持 ES6 压缩 (Webpack4 以前)
 clean-webpack-plugin: 目录清理
 webpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)
 webpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度 
```

### 热更新

```
文件或者模块发生变化，webpack监听到然后重新打包，根据变化的内容生成两个补丁文件manifest（包含了 hash 和 chunkId ，用来说明变化的内容）和 chunk.js 模块
由于服务器HMR serve和客户端HMR runtime通过websocket建立了连接，服务器发送这两个文件，客户端通过对比，通过HMR Runtime机制针对修改的模块进行更新。
```

### source map追踪错误位置

```
如果将三个源文件（`a.js`, `b.js` 和 `c.js`）打包到一个 bundle（`bundle.js`）,某一个出错了，将无法判断谁出错
```

### Tree shaking

```diff
避免引入未使用的export,减少bundle.js的大小
+ mode: "production"
生产环境中会自动压缩输出 
在开发环境中，使用UglifyJSPlugin 实现
```

### 代码分离

```
a.js b.js 共同引用了c.js，造成打包后的bundle.js体积过大
CommonsChunkPlugin插件可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。
```

### 借助Webpack来优化性能

```
CSS代码压缩:css-minimizer-webpack-plugin
Html文件代码压缩: 是否折叠空格, 是否移除注释
图片和文件压缩：compression-webpack-plugin
Tree shaking
代码分离
```

### 提高Webpack的构建速度

```
优化 Loader 配置
合理使用使用 cache-loader
开启多线程
webpack-parallel-uglify-plugin: 多线程执行代码压缩，提升构建速度 
```

### 兼容性问题

**ES6高级语法兼容**

```
npm i babel-loader @babel/core -D
1.基本js兼容性处理：需要的工具–>@babel/preset-env
2.全部js兼容性处理：需要的工具–>@babel/polyfill  解决promise
3.按需js兼容性处理：需要的工具–> corejs
```





## 其他：

### 0.1+0.2==0.3  false

js使用的协议，因为浮点数用二进制表达无穷，协议只支持64位，截断再相加造成了误差。

```
(s) * (m) * (2 ^ e)
s是符号位，m是有效数字，e是指数位
m有52位，e有11位
js 里整数可以被精确表示的范围是-2 ^ 53 + 1 ~ 2 ^ 53 - 1
```

存储位数的限制，使四舍五入变为了0舍1入，

0.1转化为二进制
0.0 0011 0011 0011 0011 0011 0011 ... （0011循环）

0.2 转化为二进制
0.0011 0011 0011 0011 0011 0011 0011 ... （0011循环）

用64位浮点数表示

```js
// 0.1
e = -4;
m = 1.1001100110011001100110011001100110011001100110011010 (52位)
+
// 0.2
e = -3;
m = 1.1001100110011001100110011001100110011001100110011010 (52位)
```

一般是往右移，因为即使右边溢出了，损失的精度远远小于左移时的溢出。

```js
e = -3; m = 0.1100110011001100110011001100110011001100110011001101 (52位)
+
e = -3; m = 1.1001100110011001100110011001100110011001100110011010 (52位)
```

**得到**

```
e = -3; m = 10.0110011001100110011001100110011001100110011001100111 (52位)
```

**保留一位整数**

```js
e = -2; m = 1.00110011001100110011001100110011001100110011001100111 (53位)
溢出来了（超过了52位）,比如1.101要保留2位小数，那么结果有可能是 1.10 和 1.11 ,保留偶数1.10
//最后得到
1.0011001100110011001100110011001100110011001100110100 * 2 ^ -2
```

Number.EPSILON是可以表示的最小精度

```
转换为整数再运算(0.1*10+0.2*10)/10
```



### 哈希表=散列表

传入key,hash(key)得到非负整数，存储

解决散列冲突

一、开放寻址法

1.线性探测

```
1.插入数据：当我们往散列表中插入数据时，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找（到底后从头开始），看是否有空闲位置，直到找到为止。
2.查找数据：如果遍历到数组的空闲位置还未找到，就说明要查找的元素并没有在散列表中。
3.删除数据：为了不让查找算法失效，可以将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。
```

2.开放定址法

```
d i = 12 , -12 , 22, -22 …… q2 , -q2 （q <= m/2），这样就等于可以是双向寻找可能的位置了，
```

二。链表法

hash相同，则开辟链表



### 2g内存，10g数据

```
分别排序：根据内存1G，数据10G，我们将10G数据切分成10份，通过内存调用磁盘的方式，每1G进行排序，排序结束后，我们会得到10个有序的数据数组。
归并：多路归并过程可以使用败者树或最小堆。为方便起见我还是用最小堆吧，原理是一样的。
内存中开辟一个大小为10的最小堆，和一个缓冲区（小于1G，不要太小）。
取10份排序好的数据的首位进入最小堆。则最小的数位于堆顶，移除堆顶元素并写入缓冲区，然后从移除元素的元素所属数组中的下一位进入最小堆，在次移除堆顶进入缓冲区...直到缓冲区满，缓冲区回写磁盘，清空缓冲区，再次将数据置入最小堆...
直到10份数据全部写完，然后将最小堆的元素按顺序回写磁盘即可。
```

### Mysql和mongoDB的区别

```
Mysql:是关系型数据库，将数据存于表中，对于数据结构和类型有强制要求，适用于数据的隐私性和完整性要求较高（银行和会计系统）
mongoDB：是基于文件存储的，数据以JSON文件的键值对形式存在，适用于非结构化数据，高容量环境下适用。
```

### 设计模式

```
1.单例模式
整个程序中只有一个实例，vuex  vue-router
2.工厂模式
传入参数即可创建实例，虚拟Dom根据传入的参数返回标签node或者组件node
3.观察者模式
vue的响应式原理
4.发布订阅模式
	数据响应式原理中watcher发布订阅模式,
	生命周期钩子函数，
	$on $emit维护一个事件中心，on的时候将事件按名称存在事件中心里，称之为订阅者，然后emit将对应的事件进行发布，去执行事件中心里的对应的监听器。
5.@装饰器模式
```

### 首屏时间计算

```
页面的图片加载速度最慢,单个页面的TCP连接数是有限制的。构建完dom树，获取所有图片标签，监听onload事件，用最大加载时间减去进入的时间。
```

### 大量的数据渲染，比如刷短视频这样的场景，该怎么优化？ 

```
-  后端对数据进行分页处理，前端每次请求并渲染少量数据 
-  维持整个数据列表的一个[最大数]()据上限，类似于一个滑动窗口 
-  当用户即将访问窗口底部的数据，请求后端服务加载新的数据并填充 
-  当整个窗口的数据量达到我们指定的渲染上限时，移除窗口头部的部分数据 
-  确保整个列表容器的总数据量不会太大 
-  在渲染数据时，必须确保每一条数据有唯一的标识作为key值，以提升列表渲染性能
```

### 为什么使用axios

```
在浏览器中发送XMLHttpRequests请求
在node.js中发送http请求
支持Promise API
拦截请求和响应x
转换请求和响应数据，比如响应回来的内容自动转换为json类型的数据
提供了一些并发请求的接口（重要，方便了很多的操作）
	传统的Ajax是基于XMLHttpRequest，配置和调用方式非常混乱，编码看起来就非常冗余
	而jquery封装的ajax也不常用，jQuery代码1w+。vue的代码才1w+
```

### 减少http请求的方法

```
图片使用雪碧图,尽量使用浏览器的缓存机制，配置多个域名，使用内容分发网络cdn
```

### 状态码如何返回

```
服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求
```



# 项目

### 底部导航按钮的实现

父组件首先确定自己的位置，并且使用display:flex;   让子组件flex布局，定义插槽slot，justify-content:center;

子组件的flex:1，既当空间足够则自动变大，设置插槽留给图片，选中图片以及文字的插槽，以及点击事件（参数为当前点击绑定的路由）

使用组件时，使用一个父组件，多个子组件充当插槽，然后传入相应的图片和参数

### Tabcontrol的吸顶效果

​                                 <img src="C:\Users\halo\Desktop\前端知识点.assets\image-20220323102606139.png" alt="image-20220323102606139" style="zoom:50%;" />                                          <img src="C:\Users\halo\Desktop\前端知识点.assets\image-20220323103832059.png" alt="image-20220323103832059" style="zoom: 50%;" />

```
1.首先需要知道该组件与顶部的offsettop，因为轮播图加载费时，在轮播图加载第一张图片完成时，下面所有的组件都完成了加载，既在了自己在的位置。通过绑定图片的load函数，向父组件发送一事件，父组件接收后绑定自己的方法，在自己的方法中获取该组件的offsettop。则实现了子组件加载，父组件在该图片加载时调用方法
2.父组件的方法知道了tabcontrol的offettop，复制一份tabcontrol,定义一个istabfixed用于判断是否吸顶，当页面超过了，令其为true,复制的tabcontrol则利用v-show = "istabfixed"进行显示
```

### 上拉加载更多

```
长列表，当滑倒底部，上拉使其加载新数据，利用scroll.on监听是否滚动到底部，然后向外emit事件，父组件接收，绑定自己获取数据的函数，完成后结束上拉
```

### vuex使用

```
state中声明一个cartlist，用来存放当前用户添加了哪些物品，并且物品的数量是多少
判断payload既商品信息对象，若cartlist查找到了该id，则其count++,否则将该对象添加cartlist，并且添加一属性count=1
```

### 图片懒加载

```
如何判断当前元素是否进入界面，给定元素的offsetTop(是正数值),判断scrolller插件positonY的位置，
positon.y是负值，-positon.y > this.tabOffsetTop;说明当前滚动已经到达元素位置了
```

vue-lazyload插件

<img src="file://D:/%E5%89%8D%E7%AB%AF/%E7%AC%94%E8%AE%B0/bad699dd34fb426db89fb1f6de1ee624.png?lastModify=1636010693" alt="img" style="zoom: 67%;" />

在img中添加 v-lazy指令

<img src="file://D:/%E5%89%8D%E7%AB%AF/%E7%AC%94%E8%AE%B0/1318cd000f5044e09e0b4c370103f4f2.png?lastModify=1636010693" alt="img" style="zoom: 67%;" />

# 代码

### 不熟悉的语法API

#### Object.hasOwnProperty()

```js
let items ={
'name':'tom',
'age':'65',
'sex':'男',
}
return this.items.hasOwnProperty('name');//找的其实是对象中的键名
```

#### Object.keys()

```js
/*返回给定对象所有可枚举属性的字符串数组*/
//相当于返回了所有的key
let items ={
'name':'tom',
'age':'65',
'sex':'男',
}
return Object.keys(this.items).length;//[ 'name', 'age', 'sex' ]
```

#### 删除对象中的属性delete

```js
let items ={
    'name':'tom',
    'age':'65',
    'sex':'男',
    }
delete items['name'];//用delete删除
//{ age: '65', sex: '男' }
```

#### Array.from

Array.from()⽅法就是将⼀个类数组对象或者可遍历对象转换成⼀个真正的数组
1、该类数组对象必须具有length属性，⽤于指定数组的长度。如果没有length属性，那么转换后的数组是⼀个空数组。
2、该类数组对象的属性名必须为数值型或字符串型的数字
ps: 该类数组对象的属性名可以加引号，也可以不加引号

```js
let arrayLike = {
    0: 'tom',
    1: '65',
    2: '男',
    3: ['jane', 'john', 'Mary'],
    length: 4
}
let arr = Array.from(arrayLike)
console.log(arr)// ['tom','65','',['jane','john','Mary']]

let arr =[12,45,97,9797,564,134,45642]
letset=new Set(arr)
console.log(Array.from(set))// [ 12, 45, 97, 9797, 564, 134, 45642 ]
```

#### fruits.entries()

```js
var fruits = ["Banana", "Orange", "Apple", "Mango"];//是一迭代器
console.log(fruits.entries().next().value);//output: [0,'Banana']
    for (const [i, ch] of fruits.entries()) {//i 是下标，ch是具体的值
	}
```

#### countBy(s)

```js
// _.countBy,统计s字符串中每个字符出现的次数，返回一对象，存储键值对
const frequency = _.countBy(s);
```

#### Array.isArray(item)

```js
Array.isArray(item)//判断某个对象是不是数组
```

#### str中的splice和substring

```js
两者都会返回字符串，且不修改原str
var sMyString = "Tsinghua University";
sMyString.slice(2,0); // ""
sMyString.substring(2,0); // "Ts"

sMyString.slice(-2,4); // ""
sMyString.substring(-2,4); // "Tsin"

sMyString.slice(-2,-4); // ""
sMyString.substring(-2,-4); // ""

sMyString.slice(2,-4); // "inghua Univer"
sMyString.substring(2,-4); // "Ts"
```

#### arr.reduce()

```js
接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。对空数组是不会执行回调函数的。
arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])
如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。
1.数组求和
    let arr = [1, 23, 4, 5, 6]
    let res = arr.reduce((total, currentValue) => {
        return total + currentValue;
    });
2.二维数组拼接
    var twoArr = [['mu','zi'],['dig','big'],['lucky','jiji']];
    let res = twoArr.reduce((pre, next) => {
        return pre.concat(next);
    });
3.统计数组单词数量
    var arr = ["apple", "orange", "apple", "orange", "pear", "orange"];
    let res = arr.reduce((pre, next) => {//给定初始值为一个对象，则pre就是初始值一个空对象，next为第0个元素
        pre[next] = (pre[next] + 1) || 1
        return pre
    }, {});
```

#### String.match（）

```js
满足正则表达式规则的字符字串，存入数组
var str="The rain in SPAIN stays mainly in the plain"; 
var n=str.match(/ain/gi);// /gi全局匹配忽略，大小写
//[ 'ain', 'AIN', 'ain', 'ain' ]
```

#### valueOf()和toString()

```js
valueOf()用于返回对象的原始值，主要是针对对象
//undefined和null没有valueOf()
let newBool = new Boolean(true);
console.log(newBool);//是一个对象
console.log(newBool.valueOf());//就是boolean类型 true or false
console.log(newBool.valueOf() == newBool);//隐式转换 true
console.log(newBool.valueOf() === newBool);// false (boolean !== Object)   


toString()用于返回变量的字符串形式
7种数据类型中，除了undefined和null类型之外，都有toString方法。
对象：Object.toString()//[object Object]
数组：[new Date(), 123, '23'].toString();//Tue Apr 26 2022 21:58:17 GMT+0800 (中国标准时间),123,23
	//遍历数组的元素，每个元素调用自己的toString()
	 [1,23,4].toString();//1,2,3,4
```



### ajax

```js
var xhr = new XMLHttpRequest();
xhr.open('get', url);//1.设置请求方式和目标url
xhr.setRequestHeader(header);//2.设置请求头内容
xhr.send(data)//3.发送数据
xhr.onreadystatechange = function () {//监听状态变化
    if (xhr.status === 200 && xhr.readyState === 4) {//返回状态码为200且ready状态为4
        console.log(xhr.responseText);//响应内容
    }
}
ajax的5种状态(readyState):

0 : 未初始化，还未调用open方法
1 ：载入中，已调用send方法发送请求
2 ：载入已完成，send方法执行完成，已收到全部响应信息
3 ：交互，正在解析响应内容
4 ：完成，响应内容解析完成
```



### 归并排序

```js
function mergesort(arr) {
    const n = arr.length;
    if (n < 2) return arr;//退出条件
    let mid = Math.floor(n / 2);
    let left = arr.slice(0, mid);
    let right = arr.slice(mid);//从mid一直到末尾
    return merge(mergesort(left), mergesort(right));
}

function merge(left, right) {//将排序好的子序列进行合并
    let res = [];
    while (left.length && right.length) {
        if (left[0] < right[0]) {
            res.push(left.shift());//用shift出栈
        } else {
            res.push(right.shift());
        }
    }
    while (left.length) {
        res.push(left.shift());
    }
    while (right.length) {
        res.push(right.shift());
    }
    return res;
}

console.log(mergesort([5, 4, 3, 2, 1, 2, 3, 1]));
```



### 插入排序

```js
function insertsort(arr) {//实现原地操作
    const n = arr.length;
    if (!n) return [];
    for (let i = 1; i < n; i++) {
        let temp = arr[i];
        let preidx = i - 1;
        while (preidx >= 0 && temp < arr[preidx]) {
            arr[preidx + 1] = arr[preidx];
            preidx--;
        }
        arr[preidx + 1] = temp;
    }
    return arr;
}

let arr = [1, 5, 8, 2, 3, 4, 8, 9, 5, 6, 2, 3]

console.log(insertsort(arr));
```



### 希尔排序

```js
function shellSort(arr) {
    var len = arr.length;
    //每次gap/2
    for (var gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {
        for (var i = gap; i < len; i++) {
            var j = i;
            var current = arr[i];
            while (j - gap >= 0 && current < arr[j - gap]) //前面的比当前的大，互换位置
                 arr[j] = arr[j - gap];
                 j = j - gap;
            }
            arr[j] = current;
        }
    }
    return arr;
}		
```

### 快速排序

```js
let quick = (arr) => {
    if (arr.length <= 1) return arr;//出口
    let left = [];
    let right = [];
    let index = Math.floor(arr.length / 2);
    let pivot = arr.splice(index, 1)[0];//截取出来是个数组
    let p = 0;
    while (p < arr.length) {
        if (arr[p] < pivot) left.push(arr[p]);
        else right.push(arr[p])
        p++;
    }
    return quick(left).concat([pivot], quick(right));//又得把数字变为数组才能concat
}	
```

```js
function quickSort(arr, begin, end) {
    if (begin >= end) return;//一定要注意这个条件
    let base = arr[begin];
    let i = begin, j = end;
    while (i < j) {
        while (i < j && arr[j] >= base) j--;//从尾部找到第一个小于base的值
        while (i < j && arr[i] <= base) i++;//从头部找到第一个大于base的值
        if (i < j) {
            [arr[i], arr[j]] = [arr[j], arr[i]];//i,j位置互换
        }
    }//退出时i===j
    arr[begin] = arr[j];
    arr[j] = base;//确定了一个元素的位置
    quickSort(arr, begin, i - 1);
    quickSort(arr, i + 1, end);
}
let arr = [5, 1, 4, 7, 2, 5, 5, 3, 6]
quickSort(arr, 0, arr.length - 1)
console.log(arr);
```

#### 找第k大的数

```js
let quick = (arr, left, right) => {
    if (left >= right) return left;
    let i = left, j = right;
    let pivot = arr[left];//记录起始位置的值
    while (i < j) {
        while (arr[j] >= pivot && i < j) {
            j--;
        }
        while (arr[i] <= pivot && i < j) {
            i++;
        }
        if (i < j) {
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    arr[left] = arr[j];
    arr[j] = pivot;
    return j;
}
let findK = (arr, k) => {
    let targetIndex = arr.length - k;//目标找到第K大的数
    let start = 0, end = arr.length - 1;
    let index = quick(arr, start, end);
    while (index !== targetIndex) {
        if (index > targetIndex) {
            index = quick(arr, start, index - 1);
        } else {
            index = quick(arr, index + 1, end)
        }
    }
    return arr[index];
}

let arr = [2, 2, 3, 1, 4, 3, 5, 5, 5, 5, 5, 6];
console.log(findK(arr, 4));
```

#### 返回前k大的数

思想和快排类似，每次的j都是当前数字在最终排序数组的位置

```js
function quick(arr, left, right) {
    if (left >= right) return left;
    let i = left, j = right;
    let pivot = arr[left];//记录起始位置的值
    while (i < j) {
        while (arr[j] >= pivot && i < j) {
            j--;
        }
        while (arr[i] <= pivot && i < j) {
            i++;
        }
        if (i < j) {
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    arr[left] = arr[j];
    arr[j] = pivot;
    return j;
}
function findk(arr, k) {//返回前k个数
    let left = 0, right = arr.length - 1;
    let index = quick(arr, left, right);
    while (index !== k - 1) {
        if (index > k - 1) {
            index = quick(arr, left, index - 1);
        } else {
            index = quick(arr, index + 1, right);
        }
    }
    return arr.slice(0, k);
}
let arr = [2, 2, 3, 1, 4, 3, 5, 5, 5, 5, 5, 6];
console.log(findk(arr, 7));
```



### 二分查找

#### 查找元素是否在数组中

```js
function find(arr, target) {
    let n = arr.length;
    if (!n) return -1;
    let mid = Math.floor(n / 2);
    if (arr[mid] < target) {
        return find(arr.slice(mid + 1), target);//注意范围
    } else if (arr[mid] > target) {
        return find(arr.slice(0, mid), target);//注意范围
    } else return target;
}

let arr = [1, 3, 4, 5, 5, 6, 7, 9, 11];
console.log(find(arr, 1));
```

#### 查找第一个大于等于target的数/最后一个小于target的数

```js
function find(arr, target) {
    let left = 0, right = arr.length;//right必须等于arr长度，包含未找到的情况
    while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        if (arr[mid] < target) left = mid + 1;//arr[mid]<target就会往右移动，
                                            //所以right是第一个大于等于target的数
        else right = mid;
    }
    //left ===right最终
    return right === arr.length ? -1 : arr[right];//第一个大于等于target的数
    return right === arr.length ? -1 : arr[right - 1];//最后一个小于target的数
}

let arr = [1, 3, 4, 5, 5, 6, 7, 9, 11];
console.log(find(arr, 2));
```

#### 查找第一个大于target的数/最后一个小于等于target的数

```js
function find(arr, target) {
    let left = 0, right = arr.length;
    while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        if (arr[mid] <= target) left = mid + 1;//arr[mid]<target就会往右移动，
        //所以right是第一个大于等于target的数
        else right = mid;
    }
    //left ===right最终
    return right === arr.length ? -1 : arr[right];//第一个大于target的数
    return right === arr.length ? -1 : arr[right - 1];//最后一个小于等于target的数
}

let arr = [1, 3, 4, 5, 5, 6, 7, 9, 11];
console.log(find(arr, 2));
```



### N数之和

```js
let arr = [1, 0, -1, 0, -2, 2];//n数之和
function sumn(arr, n, target) {//给定数组，数字个数，目标和
    arr.sort();
    let res = [];
    const len = arr.length;
    let visit = new Array(len);
    let dfs = (temp, sum, start) => {
        if (sum === target && temp.length === n) return res.push(temp);
        for (let i = start; i < len; i++) {
            if (i > start && arr[i - 1] === arr[i]) continue;
            temp.push(arr[i]);
            dfs(temp.slice(), sum + arr[i], i + 1);
            temp.pop();
        }
    }
    dfs([], 0, 0);
    return res;
}
console.log(sumn(arr,4,0));
```

### 二叉树路径总和

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

```js
var pathSum = function (root, targetSum) {
    if (!root) return [];
    let res = [];
    let dfs = (root, temp, sum) => {
        temp.push(root.val);
        sum += root.val;
        if (!root.left && !root.right) {
            if (sum === targetSum) return res.push(temp)
            return;
        }
        root.left && dfs(root.left, temp.slice(), sum)
        root.right && dfs(root.right, temp.slice(), sum)
    }
    dfs(root, [], 0);
    return res;
};
```



### 防抖函数

es6

```js
function debouce(func, delay) {
    let timer = null;
    return function () {
        if (timer) clearTimeout(timer);
        timer = setTimeout(() => {
            func.apply(this, arguments);//this指向返回的function函数调用的对象
        }, delay);
    }
}
```

错误写法

```js
function debounce(func, delay){
    let timer = null;
    return function(){
        clearTimeout(timer);
        timer = setTimeout(function(){
            func.apply(this, arguments); // 一定不能这样做，此时 this 一般指向 window
        }, delay);
    }
}
```



### 节流函数

在某段时间内只执行一次的事件，一般绑定事件会触发throttle函数，到真正调用func时远大于delay

时间戳

```js
//会立即执行第一次操作的函数，后面如果多次触发，得判断是否超过设定的delay
function throttle(func, delay) {
    let starttime = new Date();
    return function () {
        let cur = new Date();
        if (cur - starttime >= delay) {
            starttime = cur;
            func.apply(this, arguments);
        }
    }
}
function handle() {            
　　console.log(Math.random());        
}        
window.addEventListener('scroll', throttle(handle, 1000));
```

定时器

```js
// 节流throttle代码（定时器）：不会立刻执行第一次的，会给第一次设定一个timer,第一次触发延迟delay执行；
var throttle = function(func, delay) {            
    var timer = null;            
    return function() {                              
        if (!timer) {//若timer为空，说明上次的还没执行，所以本次直接忽略                    
            timer = setTimeout(()=> {                        
                func.apply(this, arguments);                        
                timer = null;                    
            }, delay);                
        }            
    }        
}        
function handle() {            
    console.log(Math.random());        
}        
window.addEventListener('scroll', throttle(handle, 1000));
```

```js
//定时器加时间戳

function throttle(func, delay) {
    let timer = null;
    let starttime = new Date();
    return function () {
        let cur = new Date();
        let remaintime = delay - (cur - starttime);//剩余多少时间才能执行
        if (remaintime <= 0) {//说明时间差已经很大，立即执行
            func.apply(this, arguments);
            starttime = cur
        } else {
            timer = setTimeout(func, remaintime);//剩余时间流逝完执行
        }
    }
}
```

在节流函数内部使用开始时间startTime、当前时间curTime与delay来计算剩余时间remaining，当remaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重新计算一个remaining来判断当前状态。

总结

```
防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。
节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。

区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。
```

### 金钱格式化

```js
function transferMoney(money) {
    if (money || money !== null) {
        money = String(money);
        let [left, right] = money.split('.');
        right = right ? right.length >= 2 ? '.' + right.substring(0, 2) : '.' + right + '0' : '.00';

        let temp = left.split('').reverse().join('').match(/\d{1,3}/g);
        left = temp.join(',').split('').reverse().join('');
        parseFloat(money);
        return (money < 0 ? '-' : '') + left + right;
    } else if (money === 0) return '0.00';
    else return '';
}

console.log(transferMoney(221313214.05));
```



### 深拷贝

```js
//一般对象和数组对象的克隆
function deepClone(obj) {
    /*数组是对象，但是和对象又有一定区别，所以需要判断newObj是数组还是对象*/
    var newObj = obj instanceof Array ? []:{};
    //A instanceof B,B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false
    for(let i in obj) {
        let tmp = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i];
        newObj[i] = tmp;
    }
    return newObj;
}
```

### 判断两个对象内容是否一样

```js
function isObject(obj) {
	return typeof obj === 'object' && null !== obj//而且不能为null,typeof null   object
}
 
function compare(obj1, obj2) {
 	// 1.判断是不是引用类型，不是引用
 	if (!isObject(obj1) || !isObject(obj2)) {
  		return obj1 === obj2//直接返回值类型比较结果
 	}
     // 2.比较是否为同一个内存地址
     if (obj1 === obj2) return true
     // 3.比较 key 的数量
     const obj1KeysLength = Object.keys(obj1).length
     const obj2KeysLength = Object.keys(obj2).length
     if (obj1KeysLength !== obj2KeysLength) return false
     // 4.比较 value 的值
     for (let key in obj1) {
        const result = compare(obj1[key], obj2[key])
        if (!result) return false
     }
     return true
}
//对象内容的数据
let obj1 = { a: 2, c: [1, 3, 2, 5], d: { x: 1, y: 2 }, b: 3 }
let obj2 = { a: 2, b: 3, c: [1, 3, 2, 5], d: { x: 1, y: 2 } }
console.log(compare(obj1, obj2));
```

### 数组扁平化

```js
let flatten = arr => {
    const res = [];
    arr.forEach(item => {
        if (Array.isArray(item)) {
            res.push(...flatten(item))
        } else {
            res.push(item)
        }
    });
    return res;
}

arr = [1, 2, 3, [4, 5, [6, 7, 8]]];
console.log(flatten(arr));
```

### 数组去重

1.

```js
function unique(arr) {
    let obj = {}
    return arr.filter(item => {
        //arr.filter返回新数组,检查item是否符合条件
        let newItem = item + JSON.stringify(item)
        //JSON.stringify(item)将json对象转化为json字符串
        //JSON.parse(str)将json字符串转为json对象
        return obj.hasOwnProperty(newItem) ? false : obj[newItem] = true;//false则不将当前元素添加进去
    })
}
var arr = [1, 1, '1', '1', null, null, undefined, undefined, new String('1'), new String('1'), /a/, /a/, NaN, NaN];
console.log(unique(arr));//[ 1, '1', null, undefined, /a/, NaN ]
```

2.

```js
function unique(arr) {
    let res = [];
    let temp = {};
    let hasNaN = false;
    for (let i in arr) {
        if (typeof arr[i] === 'object') {//是对象直接存入
            res.push(arr[i]);//null  /a/都是对象
        } else if (arr[i] !== arr[i]) { //只有NaN!==NaN
            if (!hasNaN) {
                res.push(arr[i]);
                hasNaN = true;
            }
        } else {
            if (!temp[arr[i] + typeof arr[i]]) {//这样也能判断对象是否有某个属性
                temp[arr[i] + typeof arr[i]] = true;
                res.push(arr[i])
            }
        }
    }
    return res;
}
```

3.

```js
function unique(arr) {
    let res = [];
    for (let i in arr) {
        if (res.indexOf(arr[i]) < 0) {
            res.push(arr[i]);
        }
    }
    return res;
}
```



### 闭包实现单例

```js
let Person = function (name) {//不能写成箭头函数，要用一个变量来接收这个function
    let p;
    class Create {
        constructor(name) {
            if (!p) {
                this.name = name;//先给当前实例赋值，再令p指向这个实例
                return p = this;
            }
            return p;
        }
    }
    return Create;
}();//直接执行函数，相当于Person就是指向一个类，只不过多带了一个p变量
let p1 = new Person('HALO');
let p2 = new Person('eonothem')
console.log(p1, p2);
```



### 实现set

方法 add(),size(),remove(),values(),clear(),has()

```js
class mySet {
    constructor() {
        this.items = {};//相当于是一个对象，里面存的是键值对
    }
    has(val) {
        //调用object方法
        return this.items.hasOwnProperty(val);//找的其实是对象中的键名
    }
    size() {
        /*Object.keys()返回给定对象所有可枚举属性的字符串数组*/
        //相当于返回了所有的key
        return Object.keys(this.items).length;
    }
    add(val) { //key value相同
        if (!this.has(val)) {
            this.items[val] = val;
            return true;
        }
        return false;
    }
    remove(val) {
        //***
        if (this.has(val)) {
            delete this.items[val];//用delete删除
        }
    }
    clear() {
        this.items = {};
    }
    values() {//获取set所有的值
        let res = [];
        Object.keys(this.items).forEach(item => {//得到所有key，以数组保存，再forEach
            res.push(this.items[item]);
        })
        return res;
    }
}
```



### 解析URL

```js
/**
let url = 'https://www.aaa.com?hhhqzh=ppptyp&id=1&id=2&city=%a%a%s&enable';
obj = {
    hhhqzh: ppptyp,
    id: [1, 2];
    city: '广州',
    enable: true
}
*/
 
function parseParam(url) {
    const paramsStr = url.split('?')[1]; // 将 ？后面的字符串取出来
    const paramsArr = paramsStr.split('&'); // 将字符串以 & 分割后存到数组
    let paramsObj = {};
    paramsArr.forEach((param) => {
        // 处理有 value 的参数
        if (param.indexOf('=') !== -1) {
            let [key, val] = param.split('=');
            val = decodeURIComponent(val); // 解码 decodeURIComponent方法
            val = !isNaN(val) ? parseFloat(val) : val; // 判断是否转为数字
            if (paramsObj.hasOwnProperty(key)) {
                paramsObj[key] = [].concat(paramsObj[key], val);
            } else {
                paramsObj[key] = val;
            }
        } else {
            // 处理没有 value 的参数
            paramsObj[param] = true;
        }
    })
    return paramsObj;
}
```

### 获取页面TagName种类

```js
var r = new Set()
console.log(document.querySelectorAll('*').forEach(n=>r.add(n.tagName)))
```



### lazyman

<img src="C:\Users\halo\Desktop\前端知识点.assets\image-20220328165623677.png" alt="image-20220328165623677" style="zoom: 80%;" />

错误写法

```js
function LazyMan(name) {
    if (name) {
        console.log(`Hi I am +${name}`);
    }
    return {
        eat(food) {
            console.log(`I am eating ${food} `);
        },
        sleep(time) {
            let block = true;
            setTimeout(() => {//这里是宏任务
                console.log(`wake up after ${time}`);
                block = false;
            }, time * 1000);
            while(block){};//这里一直占用调用栈，永远处理不了宏任务
            return LazyMan();
        }
    }
}
```

正确写法

```js
class LazyMan {
    constructor(name) {
        this.name = name;
        this.taskList = [];
        console.log(`Hi! This is ${name}`);
        setTimeout(() => {
            this.next();//必须setTimeOut,使得next是宏任务,后面的才会加入task队列
        }, 0);
    }
    eat(food) {
        let _this = this;//必须用_this来接this
        let task = function () {//task被异步调用，此时的this可能不再是当前对象，所以要提前保存
            console.log(`Eat ${food}`);
            _this.next();//每个任务执行完成需要调用下一个任务
        }
        _this.taskList.push(task);//此处是this或者_this都无所谓
        return this;
    }

    sleep(time) {
        let _this = this;//必须用_this来接this
        let task = function () {
            setTimeout(() => {
                console.log(`Wake up after ${time}`);
                _this.next();//每个任务执行完成需要调用下一个任务
            }, time * 1000);
        }
        // let task = () => {//用箭头函数可以不用保存this
        //     console.log(`eat ${food}`);
        //     this.next();
        // }
        _this.taskList.push(task)
        return this;
    }
    next() {
        let fn = this.taskList.shift();
        fn && fn();
    }
}
new LazyMan('Hank').sleep(5).eat('Dinner').sleep(10).eat('Breakfast')
```



### 上下固定，中间随窗口变化而变化

```vue
<div class = 'main'>
  <div id="a">
  </div>
  <div id="b">
  </div>
  <div id="c">
  </div>
</div>
<style>
    .main{
        display:flex;
        flex-direction:column;
        height:100%;
    }
    #a{
        height:100px;
        background:red;
    }
    #b{
        flex:1;
        background:black; 
    }
    #c{
        height:100px;
        background:yellow;
    }
</style>

```



### 骰子5

```vue
<div class = 'main'>
  <div class='col'>
    <div id="item"></div>
<div id="item"></div>
  </div>
  <div class='col'>
    <div id="item"></div>
  </div>
  <div class="col">
    <div id="item"></div>
	<div id="item"></div>
  </div>
</div>
<style>
.main{
  border:solid 2px black;
  display:flex;
  height:300px;
  width:300px;
	flex-direction:column;
}
.col{
   height:100px;
  display:flex;
  justify-content:space-between;
}
.col:nth-child(2) {
    justify-content:center;
}
#item{
  border-radius:50%;
  width:33.3%;
  background:black;
}
</style>
```



### 画三角形

原理：当内容大小**趋近与零**的时候,每个边就是一个三角了。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/2/27/161d7ebd112bc745~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

```css
div{/*直角*/
  width:0px;/*内容必须设置为0*/
  height:0px;
  /* 边框大小 只设置三条边*/
	border-top:solid transparent ;
  border-right: black solid;
  border-bottom:transparent solid;
  border-width: 85px; 
}

div{/*锐角*/
    /* 内部大小 */
    width: 0px;
    height: 0px;
    /* 边框大小 */
    border-top: transparent 85px solid;
    border-right:  #4285f4 170px solid;
    border-bottom: transparent 85px solid;

}
```

### div垂直居中，左右10px，高度始终为宽度一半

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
      * {
        padding: 0;
        margin: 0;
      }

      html,
      body {
        width: 100%;
        height: 100%;
      }

      .wrapper {
        position: relative;
        width: 100%;
        height: 100%;
      }

      .box {
        margin-left: 10px;
        /* vw是视口的宽度， 1vw代表1%的视口宽度 */
        width: calc(100vw - 20px);/*必须打空格*/
        /* 宽度的一半 */
        height: calc(50vw - 10px);
        position: absolute;
        background: red;
        /* 下面两行让块垂直居中 */
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <div class="box">A</div>
    </div>
  </body>
</html>
```



### 给定start和endtime，每秒显示倒计时

```js
function countdown() {
    nowtime += 1000;//增加一秒，接近endtime
    var time = endtime - nowtime;
    if (time <= 0) {
        console.log('倒计时结束');
        return;
    }
    let h = Math.floor(time / (1000 * 60 * 60))//还剩多少小时
    let m = Math.floor(time / (1000 * 60) % 60)//还剩多少分钟，%60
    let s = Math.floor(time / 1000 % 60)//还剩多少秒
    let text = (h > 9 ? h : '0' + h) + ':' + (m > 9 ? m : '0' + m) + ':' + (s > 9 ? s : '0' + s);
    console.log(text);
    timer = setTimeout(() => {
        countdown();
    }, 1000);
}
var timer = null;
let endtime = 1459260000;
let nowtime = 1459250600;
countdown();
```



### 手写双向绑定

```js
<body>
    手写一个简单双向绑定<br/>
    <input type="text" id="model"><br/>
    <div id="modelText"></div>
</body>
<script>
    var user = {};
    var defaultName = "狂奔的蜗牛";
    var model = document.querySelector("#model");
    var modelText = document.querySelector("#modelText");

    model.value = defaultName;
    modelText.textContent = defaultName;

    //定义属性 监控改变
    Object.defineProperty(user,"name",{
        get:function(){
            console.log("你是不是来获取值啦");
            return defaultName;
        },
        set:function(newValue){
            console.log("设置新值");
            defaultName = newValue;
            model.value = newValue;
            modelText.textContent = newValue;
        }
    })

    model.addEventListener("keyup", function () {
        user.name = this.value;
        console.log("实现 视图 => 模型");
    }, false)
</script>
```



### Promise

```js
class Mypromise {
    constructor(process) {//需要传入带有两个参数的函数，两个参数是两个方法名称，已经在内部写好了
        this.statu = 'pending';
        this.msg = '';
        process(this.resolve.bind(this), this.reject.bind(this));//bind绑定，使两个函数的this永远指向当前对象,不能使用call,apply，需要返回该函数而不是执行
    }
    resolve(val) {
        if (this.statu === 'pending') {
            this.statu = 'resolved';
            this.msg = val;
        }
    }
    reject(err) {
        if (this.statu === 'pending') {
            this.statu = 'rejected';
            this.msg = err;
        }

    }
    then(onFullfilled, onRejected) {
        if (this.statu === 'resolved') {
            onFullfilled(this.msg);
        }
        if (this.statu === 'rejected') {
            onRejected(this.msg);
        }
    }
}

let p1 = new Mypromise((resolve, reject) => {
    let x = 5;
    if (x === 5) {
        resolve(5);
    }
    else reject('err');
    // setTimeout(() => {
    //     if (x === 5) {
    //         resolve(5);
    //     }
    //     else reject('err');
    // }, 1000);//开定时器后，无法执行then,因为then是同步代码
})
p1.then(val => {
    console.log(val);
}, err => {
    console.log(err);
})
```

优化版，解决上面提到的问题

```js
class Mypromise {
    constructor(process) {//需要传入带有两个参数的函数，两个参数是两个方法名称，已经在内部写好了
        process(this.resolve.bind(this), this.reject.bind(this));//bind绑定，使两个函数的this永远指向当前对象
    }
    statu = 'pending';
    msg = undefined;
    successcallback = undefined;
    failcallback = undefined;
    resolve(val) {
        if (this.statu === 'pending') {
            this.statu = 'resolved';
            this.msg = val;
            this.successcallback && this.successcallback(this.msg);
        }
    }
    reject(err) {
        if (this.statu === 'pending') {
            this.statu = 'rejected';
            this.msg = err;
            this.failcallback && this.failcallback(this.msg);//有回调函数才执行
        }

    }
    then(onFullfilled, onRejected) {
        if (this.statu === 'resolved') {//用来处理没有异步的时候
            onFullfilled(this.msg);
        }
        else if (this.statu === 'rejected') {
            onRejected(this.msg);
        } else {//假如还是pending状态
            this.successcallback = onFullfilled;
            this.failcallback = onRejected;
            //将两个回调函数存起来，后面状态改变再调用
        }
    }
}

let p1 = new Mypromise((resolve, reject) => {
    let x = 5;
    setTimeout(() => {
        if (x === 5) {
            resolve(5);
        }
        else reject('err');
    }, 1000);

}).then(val => {//这种情况then比上面的resolve先执行，将回调函数存起来，上面的resolve运行时调用对应的回调函数。
    console.log(val);
}, err => {
    console.log(err);
})
```



### PromiseAll

传统的promiseAll,有错误直接reject，成功将所有的成功promise返回

```js
const promiseall = (iterator) => {
    let promises = Array.from(iterator);//传入的可能是迭代器，将其转化为数组
    const n = promises.length;
    let idx = 0;
    let data = [];
    return new Promise((resolve, reject) => {
        for (let i in promises) {
            promises[i]
                .then(res => {
                    data.push(res);
                    if (++idx === n) {
                        resolve(data);
                    }
                }).catch(err => {
                    reject(err);
                })
        }

    })
}

const p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('promise1')
    }, 1000);
})
const p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('promise2')
    }, 2000);
})
const p3 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('promise3')
    }, 3000);
})


promiseall([p1, p2, p3]).then(res => console.log("suc:" + res)).catch(err => console.log("err:" + err));
```

改进的promiseall，中途有一个有错误，依然将其他的结果返回

```js
const promiseall = (iterator) => {
    let promises = Array.from(iterator);
    const n = promises.length;
    let idx = 0;//用于记录当前
    let data = [];//记录成功或者失败的信息
    return new Promise((resolve, reject) => {
        for (let i in promises) {
            promises[i]
                .then(res => {
                    data.push(res);
                    if (++idx === n) {//判断第几个promise执行完毕
                        resolve(data);
                    }
                }).catch(err => {
                    data.push('err');
                    if (++idx === n) {
                        reject(data);//判断第几个promise执行完毕
                    }
                })
        }

    })
}

const p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('promise1')
    }, 1000);
})
const p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        reject('promise3')
    }, 2000);
})
const p3 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('promise4')
    }, 3000);
})

promiseall([p1, p2, p3]).then(res => console.log(res)).catch(err => console.log(err));
```

### Promise.race 

返回迭代器中最快完成或者拒绝的

```js
function Promiserace(iterator) {
    const promises = Array.from(iterator);
    return new Promise((resolve, reject) => {
        promises.forEach(item => {
            item.then(val => resolve(val))
                .catch(err => reject(err))
        })
    })
}

let p1 = new Promise((res, rej) => {
    setTimeout(() => {
        res('promise1');
    }, 2000);
})
let p2 = new Promise((res, rej) => {
    setTimeout(() => {
        res('promise2');
    }, 1000);
})
let p3 = new Promise((res, rej) => {
    setTimeout(() => {
        res('promise3');
    }, 3000);
})
Promiserace([p1, p2, p3]).then(val => console.log("success:" + val)).catch(err => console.log("err:" + err));
```

### Promise.any

有一个成功就返回成功，全部失败才返回失败，和all相反

```js
function Promiseany(iterator) {
    const promises = Array.from(iterator);
    let errres = [];
    let count = 0;
    return new Promise((resolve, reject) => {
        promises.forEach(item => {
            item.then(val => resolve(val))
                .catch(err => {
                    errres.push(err);
                    if (++count === promises.length)
                        reject(err);
                })
        })
    })
}

let p1 = new Promise((res, rej) => {
    setTimeout(() => {
        rej('promise1');
    }, 2000);
})
let p2 = new Promise((res, rej) => {
    setTimeout(() => {
        rej('promise2');
    }, 1000);
})
let p3 = new Promise((res, rej) => {
    setTimeout(() => {
        rej('promise3');
    }, 3000);
})
Promiseany([p1, p2, p3]).then(val => console.log("success:" + val)).catch(err => console.log("err:" + err));
```



### 手写call

```js
Function.prototype.myapply = function (context, ...args) {
    context = context || window;//若没有this,则将context指向windows;
    let fn = Symbol('fn');//防止重名
    context[fn] = this;//让context上的fn调用mycall的对象，即要执行的函数
    const res = context[fn](...args);//保存执行结果
    delete context[fn];//删除声明属性
    return res;//返回结果
}
let obj = { x: 100 };
function fn1(a, b, c) {
    console.log(this);
    console.log(a, b, c);
}
fn1.myapply(obj, 10, 20, 30);
```

### 手写apply

```js
Function.prototype.myapply = function (context, args) {//apply参数是数组，不需要扩展运算符了。
    context = context || window;
    const fn = Symbol('fn');
    context[fn] = this;
    const res = context[fn](...args);
    delete fn;
    return res;
}
let obj = { x: 100 };
function fn1(a, b, c) {
    console.log(this);
    console.log(a, b, c);
}
fn1.myapply(obj, [10, 20, 30]);
```

### 手写bind

所以在下一次我们执行bind操作的时候，实际上是给新返回来的函数绑定的this。
你虽然可以绑定成功，也可以把this添加进去，但是确无法改变第一层的调用啊。

简单来说，再次bind的时候，我们已经无法对最原始的待绑定函数进行操作了，我们操作的只是它的代理

```js
function isObject(it) {//是数组，对象，方法都是对象
    return typeof it === 'object' ? it !== "null" : typeof it === 'function';
}
Function.prototype.mybind = function (context, ...args) {//传入的不是数组，是类数组
    //检查调用mybind函数的是不是一个函数
    if (typeof this !== 'function') throw new Error('调用的不是函数');
    const F = this;//记录调用mybind的函数对象
    const Prototype = F.prototype;//记录其函数的原型对象
    function bindFun(...arr) {//后续调用可能还会携带参数
        //第一次调用bind返回了bindFun,第二次的相当于执行bindFun.mybind()
        return F.apply(this instanceof bindFun ? this : context, [...args, ...arr]);
    }
    //维护原有的原型关系
    if (isObject(Prototype)) {
        bindFun.prototype = Prototype;
    }
    return bindFun;
}
let a = {
    name: "张三"
};
let b = {
    name: "李四"
}
let c = {
    name: "赵五"
}
function getName() {
    console.log(this.name);
}
getName.mybind(a).mybind(b).mybind(c)();//张三
```

